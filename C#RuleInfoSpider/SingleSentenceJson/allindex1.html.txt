{"role_title": "“CoSetProxyBlanket”和“CoInitializeSecurity”不应该被使用.", "role_desc_en": "CoSetProxyBlanket and CoInitializeSecurity both work to set the permissions context in which the process invoked immediately after is executed. Calling them from within that process is useless because it's to late at that point; the permissions context has already been set.Specifically, these methods are meant to be called from a non-managed code such as a C++ wrapper that then invokes the managed, i.e. C# or VB.NET, code.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\n[DllImport(\"ole32.dll\")]\nstatic extern int CoSetProxyBlanket([MarshalAs(UnmanagedType.IUnknown)]object pProxy, uint dwAuthnSvc, uint dwAuthzSvc,\n\t[MarshalAs(UnmanagedType.LPWStr)] string pServerPrincName, uint dwAuthnLevel, uint dwImpLevel, IntPtr pAuthInfo,\n\tuint dwCapabilities);\n\npublic enum RpcAuthnLevel\n{\n\tDefault = 0,\n\tNone = 1,\n\tConnect = 2,\n\tCall = 3,\n\tPkt = 4,\n\tPktIntegrity = 5,\n\tPktPrivacy = 6\n}\n\npublic enum RpcImpLevel\n{\n\tDefault = 0,\n\tAnonymous = 1,\n\tIdentify = 2,\n\tImpersonate = 3,\n\tDelegate = 4\n}\n\npublic enum EoAuthnCap\n{\n\tNone = 0x00,\n\tMutualAuth = 0x01,\n\tStaticCloaking = 0x20,\n\tDynamicCloaking = 0x40,\n\tAnyAuthority = 0x80,\n\tMakeFullSIC = 0x100,\n\tDefault = 0x800,\n\tSecureRefs = 0x02,\n\tAccessControl = 0x04,\n\tAppID = 0x08,\n\tDynamic = 0x10,\n\tRequireFullSIC = 0x200,\n\tAutoImpersonate = 0x400,\n\tNoCustomMarshal = 0x2000,\n\tDisableAAA = 0x1000\n}\n\n[DllImport(\"ole32.dll\")]\npublic static extern int CoInitializeSecurity(IntPtr pVoid, int cAuthSvc, IntPtr asAuthSvc, IntPtr pReserved1,\n\tRpcAuthnLevel level, RpcImpLevel impers, IntPtr pAuthList, EoAuthnCap dwCapabilities, IntPtr pReserved3);\n\nstatic void Main(string[] args)\n{\n\tvar hres1 = CoSetProxyBlanket(null, 0, 0, null, 0, 0, IntPtr.Zero, 0); // Noncompliant\n\n\tvar hres2 = CoInitializeSecurity(IntPtr.Zero, -1, IntPtr.Zero, IntPtr.Zero, RpcAuthnLevel.None,\n\t\tRpcImpLevel.Impersonate, IntPtr.Zero, EoAuthnCap.None, IntPtr.Zero); // Noncompliant\n}\n\n", "role_origin_id": "rule_RSPEC-3884", "role_id": "S3884", "role_desc": "CoSetProxyBlanket和CoInitializeSecurity都可以设置执行后立即调用该进程的权限上下文.在这个过程中召唤他们是无用的，因为那时候迟到了;.具体来说，这些方法意在从非托管代码调用，例如C ++包装器，然后调用受管理的.C＃或VB.NET，代码.", "role_type": "Vulnerability", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "BLOCKER", "role_title_en": "\"CoSetProxyBlanket\" and \"CoInitializeSecurity\" should not be used"},{"role_title": "“IDisposables”应该被处理.", "role_desc_en": "When writing managed code, you don't need to worry about allocating or freeing memory: The garbage collector takes care of it. For efficiency reasons, some objects such as Bitmap use unmanaged memory, enabling for example the use of pointer arithmetic. Such objects have potentially huge unmanaged memory footprints, but will have tiny managed ones. Unfortunately, the garbage collector only sees the tiny managed footprint, and fails to reclaim the unmanaged memory (by calling Bitmap's finalizer method) in a timely fashion. Moreover, memory is not the only system resource which needs to be managed in a timely fashion: The operating system can only handle having so many file descriptors (e.g. FileStream) or sockets (e.g. WebClient) open at any given time. Therefore, it is important to Dispose of them as soon as they are no longer needed, rather than relying on the garbage collector to call these objects' finalizers at some nondeterministic point in the future.This rule tracks private fields and local variables of the following IDisposable types, which are never disposed, closed, aliased, returned, or passed to other methods.which are either instantiated directly using the new operator, or using one of the following factory methods:on both private fields and local variables.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class ResourceHolder \n{\n  private FileStream fs; // Noncompliant; Dispose or Close are never called\n\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open);\n  }\n\n  public void WriteToFile(string path, string text)\n  {\n    var fs = new FileStream(path, FileMode.Open); // Noncompliant\n    var bytes = Encoding.UTF8.GetBytes(text);\n    fs.Write(bytes, 0, bytes.Length);\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2930", "role_id": "S2930", "role_desc": "编写托管代码时，您不必担心分配或释放内存：垃圾回收器负责处理.出于效率的原因，一些诸如Bitmap的对象使用非托管内存，例如使用指针算术.这样的对象具有潜在的巨大的非管理内存占用空间，但将具有微小的管理内存.不幸的是，垃圾收集器只能看到微小的管理足迹，并且无法及时收回非托管内存（通过调用Bitmap的终结器方法）.此外，内存不是需要及时管理的唯一系统资源：操作系统只能处理具有如此多的文件描述符（e.G.FileStream）或套接字（e.G.WebClient）在任何给定的时间打开.因此，重要的是一旦不再需要处理它们，而不是依靠垃圾收集器在将来的某个非确定性点将这些对象的终止者称为“非确定性”.此规则跟踪以下IDisposable类型的私有字段和局部变量，这些类型不会被处理，关闭，别名，返回或传递给其他方法.它们可以直接使用新的运算符进行实例化，也可以使用以下工厂方法之一：.在私有字段和局部变量上.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class ResourceHolder : IDisposable\n{\n  private FileStream fs;\n\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open);\n  }\n\n  public void Dispose() \n  {\n    this.fs.Dispose();\n  }\n\n  public void WriteToFile(string path, string text)\n  {\n    using (var fs = new FileStream(path, FileMode.Open))\n    {\n      var bytes = Encoding.UTF8.GetBytes(text);\n      fs.Write(bytes, 0, bytes.Length);\n    }\n  }\n}\n\n", "role_level": "BLOCKER", "role_title_en": "\"IDisposables\" should be disposed"},{"role_title": "“的SafeHandle.DangerousGetHandle“不应该被调用.", "role_desc_en": "Not surprisingly, the SafeHandle.DangerousGetHandle method is dangerous. That's because it may not return a valid handle. Using it can lead to leaks and vulnerabilities. While it is possible to use the method successfully, it's extremely difficult to do correctly, so the method should simply be avoided altogether.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nstatic void Main(string[] args)\n{\n    System.Reflection.FieldInfo fieldInfo = ...;\n    SafeHandle handle = (SafeHandle)fieldInfo.GetValue(rKey);\n    IntPtr dangerousHandle = handle.DangerousGetHandle();  // Noncompliant\n}\n\n", "role_origin_id": "rule_RSPEC-3869", "role_id": "S3869", "role_desc": "不奇怪的是，SafeHandle.DangerousGetHandle方法是危险的.这是因为它可能不会返回有效的句柄.使用它可能会导致泄漏和漏洞.虽然可以成功使用该方法，但是很难正确执行，所以该方法应该完全避免.", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "BLOCKER", "role_title_en": "\"SafeHandle.DangerousGetHandle\" should not be called"},{"role_title": "“async”和“等待”不应该用作标识符.", "role_desc_en": "Since C# 5.0, async and await are contextual keywords. Contextual keywords do have a particular meaning in some contexts, but can still be used as variable names. Keywords, on the other hand, are always reserved, and therefore are not valid variable names. To avoid any confusion though, it is best to not use async and await as identifiers.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nint await = 42; // Noncompliant\n\n", "role_origin_id": "rule_RSPEC-2306", "role_id": "S2306", "role_desc": "自C＃5.0，异步等待是上下文关键字.上下文关键字在某些上下文中具有特定的含义，但仍可用作变量名称.另一方面，关键字始终保留，因此不是有效的变量名.为了避免混淆，最好不要使用异步，等待标识符.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nint someOtherName = 42;\n\n", "role_level": "BLOCKER", "role_title_en": "\"async\" and \"await\" should not be used as identifiers"},{"role_title": "“operator ==”不应该在引用类型上重载.", "role_desc_en": "The use of == to compare to objects is expected to do a reference comparison. That is, it is expected to return true if and only if they are the same object instance. Overloading the operator to do anything else will inevitably lead to the introduction of bugs by callers. On the other hand, overloading it to do exactly that is pointless; that's what == does by default.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic static bool operator== (MyType x, MyType y) // Noncompliant\n{\n\n", "role_origin_id": "rule_RSPEC-3875", "role_id": "S3875", "role_desc": "使用==来比较对象有望做一个参考比较.也就是说，当且仅当它们是相同的对象实例时，才会返回true.重载操作员做任何其他操作将不可避免地导致呼叫者引入错误.另一方面，超载它做的确是毫无意义的;.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "BLOCKER", "role_title_en": "\"operator==\" should not be overloaded on reference types"},{"role_title": "应该使用“值”参数.", "role_desc_en": "In property and indexer set methods, and in event add and remove methods, the implicit value parameter holds the value the accessor was called with. Not using the value means that the accessor ignores the caller's intent which could cause unexpected results at runtime.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nprivate int count;\npublic int Count\n{\n  get { return count; }\n  set { count = 42; } // Noncompliant \n}\n\n", "role_origin_id": "rule_RSPEC-3237", "role_id": "S3237", "role_desc": "在属性和索引器集合方法中，在事件添加和删除方法中，implicit值参数保存访问者调用的值.不使用该值意味着访问者忽略了可能在运行时导致意外结果的调用者意图.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nprivate int count;\npublic int Count\n{\n  get { return count; }\n  set { count = value; }\n}\n\n", "role_level": "BLOCKER", "role_title_en": "\"value\" parameters should be used"},{"role_title": "公共方法不应该有多维数组参数.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Program\n{\n    public void WriteMatrix(int[][] matrix) // Non-Compliant\n    {\n    }\n}\n\n", "role_origin_id": "rule_RSPEC-2368", "role_id": "S2368", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Matrix\n{\n    // ...\n}\n\npublic class Program\n{\n    public void WriteMatrix(Matrix matrix) // Compliant\n    {\n    }\n}\n\n", "role_level": "BLOCKER", "role_title_en": "Public methods should not have multidimensional array parameters"},{"role_title": "不应使用DES（数据加密标准）和DESEDE（3DES）.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nusing (var tripleDES = new TripleDESCryptoServiceProvider()) //Noncompliant\n{\n  //...\n}\n\n", "role_origin_id": "rule_RSPEC-2278", "role_id": "S2278", "role_desc": "", "role_type": "Vulnerability", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nusing (var aes = new AesCryptoServiceProvider())\n{\n  //...\n}\n\n", "role_level": "BLOCKER", "role_title_en": "Neither DES (Data Encryption Standard) nor DESede (3DES) should be used"},{"role_title": "递归不应该是无限的.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nint Pow(int num, int exponent)   // Noncompliant; no condition under which pow isn't re-called\n{\n  num = num * Pow(num, exponent-1);\n  return num;  // this is never reached\n}\n\nvoid InternalRecursion(int i)  \n{\n  start:\n    goto end;\n  end:\n    goto start; // Noncompliant; there's no way to break out of this method\n}\n\n", "role_origin_id": "rule_RSPEC-2190", "role_id": "S2190", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nint Pow(int num, int exponent) \n{\n  if (exponent &gt; 1) // recursion now conditional and stop-able\n  {  \n    num = num * Pow(num, exponent-1);\n  }\n  return num;\n}\n\n", "role_level": "BLOCKER", "role_title_en": "Recursion should not be infinite"},{"role_title": "布尔上下文中应使用短路逻辑.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (GetTrue() | GetFalse()) // Noncompliant; both sides evaluated\n{\n}\n\n", "role_origin_id": "rule_RSPEC-2178", "role_id": "S2178", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif (GetTrue() || GetFalse()) // true short-circuit logic\n{\n}\n\n", "role_level": "BLOCKER", "role_title_en": "Short-circuit logic should be used in boolean contexts"},{"role_title": "复合格式字符串不应在运行时导致意外的行为.", "role_desc_en": "Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected behaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of String.Format, StringBuilder.AppendFormat, Console.Write, Console.WriteLine, TextWriter.Write, TextWriter.WriteLine, Debug.WriteLine(String, Object[]), Trace.TraceError(String, Object[]), Trace.TraceInformation(String, Object[]), Trace.TraceWarning(String, Object[]) and TraceSource.TraceInformation(String, Object[]). ", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\ns = string.Format(\"[0}\", arg0); \ns = string.Format(\"{{0}\", arg0);\ns = string.Format(\"{0}}\", arg0);\ns = string.Format(\"{-1}\", arg0);\ns = string.Format(\"{0} {1}\", arg0);\n\n", "role_origin_id": "rule_RSPEC-2275", "role_id": "S2275", "role_desc": "因为复合格式字符串在运行时解释，而不是由编译器验证，它们可能包含导致意外行为或运行时错误的错误.当调用String的方法时，此规则静态地验证复合格式的良好行为.格式，StringBuilder.AppendFormat，控制台.写，控制台.WriteLine，TextWriter.写，TextWriter.WriteLine，Debug.WriteLine（String，Object []），Trace.TraceError（String，Object []），Trace.TraceInformation（String，Object []），Trace.TraceWarning（String，Object []）和TraceSource.TraceInformation（字符串，对象[]）.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\ns = string.Format(\"{0}\", 42); // Compliant\ns = string.Format(\"{0,10}\", 42); // Compliant\ns = string.Format(\"{0,-10}\", 42); // Compliant\ns = string.Format(\"{0:0000}\", 42); // Compliant\ns = string.Format(\"{2}-{0}-{1}\", 1, 2, 3); // Compliant\ns = string.Format(\"no format\"); // Compliant\n\n", "role_level": "BLOCKER", "role_title_en": "Composite format strings should not lead to unexpected behavior at runtime"},{"role_title": "异常不应该从意外的方法抛出.", "role_desc_en": "It is expected that some methods should be called with caution, but others, such as ToString, are expected to \"just work\". Throwing an exception from such a method is likely to break callers' code unexpectedly.An issue is raised when an exception is thrown from any of the following: ", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic override string ToString()\n{\n  if (string.IsNullOrEmpty(Name)) \n  {\n    throw new ArgumentException(\"...\");  // Noncompliant\n  }\n  //...\n\n", "role_origin_id": "rule_RSPEC-3877", "role_id": "S3877", "role_desc": "预计应谨慎采取一些方法，但其他方法（如ToString）预计“正常工作”.从这种方法抛出异常可能会意外地中断呼叫者的代码.当从以下任何一个引发异常时，会引发一个问题：.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "BLOCKER", "role_title_en": "Exceptions should not be thrown from unexpected methods"},{"role_title": "使用默认参数值的方法重载不应重叠.", "role_desc_en": "The rules for method resolution are complex and perhaps not properly understood by all coders. Having overloads with optional parameter values makes the matter even harder to understand. This rule raises an issue when an overload with default parameter values is hidden by one without the optional parameters. ", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class MyClass\n{\n  void Print(string[] messages) {...} \n  void Print(string[] messages, string delimiter = \"\\n\") {...} // Noncompliant; default parameter value is hidden by overload\n}\n\n// ...\nMyClass myClass = new MyClass();\n\nmyClass.Print(new string[3] {\"yes\", \"no\", \"maybe\"});  // which version of Print will be called?\n\n", "role_origin_id": "rule_RSPEC-3427", "role_id": "S3427", "role_desc": "方法解决的规则是复杂的，也可能没有被所有编码人员正确理解.使用可选参数值重载可使问题更加难以理解.当具有默认参数值的重载被一个没有可选参数隐藏时，此规则引发了一个问题.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "BLOCKER", "role_title_en": "Method overloads with default parameter values should not overlap"},{"role_title": "名为“Dispose”的方法应该实现“IDisposable”.处置”.", "role_desc_en": "Dispose as a method name should be used exclusively to implement IDisposable.Dispose to prevent any confusion.It may be tempting to create a Dispose method for other purposes, but doing so will result in confusion and likely lead to problems in production.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class GarbageDisposal \n{\n  private int Dispose()  // Noncompliant\n  {\n    // ...\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2953", "role_id": "S2953", "role_desc": "处理方法名称应该专门用于实现IDisposable.处理以防止任何混淆.为其他目的创建一个Dispose方法可能是诱人的，但这样做会导致混乱，并可能导致生产中的问题.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class GarbageDisposal : IDisposable\n{\n  public void Dispose() \n  {\n    // ...\n  }\n}\n\n", "role_level": "BLOCKER", "role_title_en": "Methods named \"Dispose\" should implement \"IDisposable.Dispose\""},{"role_title": "线程.恢复“也不”线程.暂停使用“.", "role_desc_en": "Thread.Suspend and Thread.Resume can give unpredictable results, and both methods have been deprecated. Indeed, if Thread.Suspend is not used very carefully, a thread can be suspended while holding a lock, thus leading to a deadlock. Other safer synchronization mechanisms should be used, such as Monitor, Mutex, and Semaphore.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nstatic void Main(string[] args)\n{\n  // ...\n  Thread.CurrentThread.Suspend(); // Noncompliant\n  Thread.CurrentThread.Resume(); // Noncompliant\n}\n\n", "role_origin_id": "rule_RSPEC-3889", "role_id": "S3889", "role_desc": "线.暂停和线程.简历可以提供不可预测的结果，并且这两种方法都已被弃用.的确，如果线程.挂起不是非常小心地使用，一个螺纹可以在锁定时暂停，从而导致死锁.应使用其他更安全的同步机制，如监视器，互斥和信号量.", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "BLOCKER", "role_title_en": "Neither \"Thread.Resume\" nor \"Thread.Suspend\" should be used"},{"role_title": "不应执行傻位操作.", "role_desc_en": "Certain bit operations are just silly and should not be performed because their results are predictable.Specifically, using &amp; -1 with any value will always result in the original value, as will anyValue ^ 0 and anyValue | 0.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-2437", "role_id": "S2437", "role_desc": "某些位操作只是愚蠢的，不应该执行，因为它们的结果是可预测的.具体来说，使用＆amp; .", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "BLOCKER", "role_title_en": "Silly bit operations should not be performed"},{"role_title": "不应在“系统”上检查类型.键入“实例.", "role_desc_en": "If you call GetType() on a Type variable, the return value will always be typeof(System.Type). So there's no real point in making that call. The same applies to passing a type argument to IsInstanceOfType. In both cases the results are entirely predictable.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvar type = typeof(int);\nvar ttype = type.GetType(); //Noncompliant, always typeof(System.Type)\n\nvar s = \"abc\";\n\nif (s.GetType().IsInstanceOfType(typeof(string))) //Noncompliant; false\n{ /* ... */ }\n\n", "role_origin_id": "rule_RSPEC-3443", "role_id": "S3443", "role_desc": "如果在Type变量上调用GetType（），返回值将始终为typeof（System）.类型）.所以打电话没有什么意义.将类型参数传递给IsInstanceOfType也是一样.在这两种情况下，结果是完全可预测的.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvar s = \"abc\";\n\nif (s.GetType().IsInstanceOfType(\"ssss\"))\n{ /* ... */ }\n\n", "role_level": "BLOCKER", "role_title_en": "Type should not be examined on \"System.Type\" instances"},{"role_title": "不要使用“foreach”循环的“显式”转换.", "role_desc_en": "The foreach statement was introduced in the C# language prior to generics to make it easier to work with the non-generic collections available at that time such as ArrayList. The foreach statements allows you to downcast elements of a collection of Object}}s to any other type. The problem is that to achieve the cast, the {{foreach statements silently performs explicit type conversion, which at runtime can result in an InvalidCastException.C# code iterating on generic collections or arrays should not rely on foreach statement's silent explicit conversions.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Fruit { }\npublic class Orange : Fruit { }\npublic class Apple : Fruit { }\n\nclass MyTest\n{\n  public void Test()\n  {\n    var fruitBasket = new List&lt;Fruit&gt;();\n    fruitBasket.Add(new Orange());\n    fruitBasket.Add(new Orange());\n    // fruitBasket.Add(new Apple());  // uncommenting this line will make both foreach below throw an InvalidCastException\n\n    foreach (Fruit fruit in fruitBasket) \n    {\n      var orange = (Orange)fruit; // This \"explicit\" conversion is hidden within the foreach loop below\n      ...\n    }\n\n    foreach (Orange orange in fruitBasket) // Noncompliant\n    {\n      ...\n    } \n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3217", "role_id": "S3217", "role_desc": "foreach语句在泛型之前以C＃语言介绍，以便更容易使用当时可用的非泛型集合，如ArrayList.foreach语句允许您将Object}}集合的元素下拉到任何其他类型.问题是为了实现该转换，{{foreach语句静默地执行显式类型转换，在运行时可以导致InvalidCastException.对通用集合或数组进行迭代的C＃代码不应该依赖于foreach语句的静默显式转换.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvar fruitBasket = new List&lt;Orange&gt;();\nfruitBasket.Add(new Orange());\nfruitBasket.Add(new Orange());\n// fruitBasket.Add(new Apple());  // uncommenting this line won't compile\n\nforeach (Orange orange in fruitBasket)\n{\n  ...\n} \n\n", "role_level": "CRITICAL", "role_title_en": "\"Explicit\" conversions of \"foreach\" loops should not be used"},{"role_title": "“ISerializable”应该正确实现.", "role_desc_en": "The ISerializable interface is the mechanism to control the type serialization process. If not implemented correctly this could result in an invalid serialization and hard to detect bugs.This rules raises an issue on types that implement ISerializable without following the serialization pattern recommended by Microsoft.Specifically this rule checks for these problems:", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Foo : ISerializable // Noncompliant the [Serializable] attribute is missing\n{\n}\n\n", "role_origin_id": "rule_RSPEC-3925", "role_id": "S3925", "role_desc": "ISerializable接口是控制类型序列化过程的机制.如果未正确实现，可能会导致无效的序列化，并且难以检测到错误.此规则引发了在不遵循Microsoft推荐的序列化模式的情况下实现ISerializable的类型的问题.具体来说，这个规则检查这些问题：.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Bar\n{\n}\n\n[Serializable]\npublic class Foo : ISerializable\n{\n    [NonSerialized]\n    private readonly Bar bar;\n\n    public Foo()\n    {\n        // ...\n    }\n\n    protected Foo(SerializationInfo info, StreamingContext context)\n    {\n        // ...\n    }\n\n    public virtual void GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        // ...\n    }\n}\n\n[Serializable]\npublic sealed class SubFoo : Foo\n{\n    private int val;\n\n    public SubFoo()\n    {\n        // ...\n    }\n\n    private SubFoo(SerializationInfo info, StreamingContext context)\n        : base(info, context)\n    {\n        // ...\n    }\n\n    public override void GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        base.GetObjectData(info, context);\n        // ...\n    }\n}\n\n", "role_level": "MAJOR", "role_title_en": "\"ISerializable\" should be implemented correctly"},{"role_title": "“[DefaultParameterValue]”的意思是不应该使用“DefaultValue”.", "role_desc_en": "The use of [DefaultValue] with [Optional] has no more effect than [Optional] alone. That's because [DefaultValue] doesn't actually do anything; it merely indicates the intent for the value. More than likely, [DefaultValue] was used in confusion instead of [DefaultParameterValue].", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass MyClass\n{\n    public void DoStuff([Optional][DefaultValue(4)]int i, int j = 5)  // Noncompliant\n    {\n        Console.WriteLine(i);\n    }\n\n    public static void Main()\n    {\n        new MyClass().DoStuff(); // prints 0\n    }\n}\n\n", "role_origin_id": "rule_RSPEC-3451", "role_id": "S3451", "role_desc": "[DefaultValue]与[可选]的使用比单独的[可选]更有效果.那是因为[DefaultValue]实际上没有做任何事情;.更有可能的是，[DefaultValue]被用于混淆而不是[DefaultParameterValue].", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass MyClass\n{\n    public void DoStuff([Optional][DefaultParameterValue(4)]int i, int j = 5) \n    {\n        Console.WriteLine(i);\n    }\n\n    public static void Main()\n    {\n        new MyClass().DoStuff(); // prints 4\n    }\n}\n\n", "role_level": "CRITICAL", "role_title_en": "\"[DefaultValue]\" should not be used when \"[DefaultParameterValue]\" is meant"},{"role_title": "“ref”或“out”参数不能使用“[可选]”.", "role_desc_en": "The use of ref or out in combination with [Optional] is both confusing and contradictory. [Optional] indicates that the parameter doesn't have to be provided, while out and ref mean that the parameter will be used to return data to the caller (ref additionally indicates that the parameter may also be used to pass data into the method).Thus, making it [Optional] to provide the parameter in which you will be passing back the method results doesn't make sense. In fact, the compiler will raise an error on such code. Unfortunately, it raises the error on method calls where the [Optional] parameter has been omitted, not the source of the problem, the method declaration. ", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass MyClass\n{\n    public void DoStuff([Optional] ref int i) // Noncompliant\n    {\n        Console.WriteLine(i);\n    }\n\n    public static void Main()\n    {\n        new MyClass().DoStuff(); // This doesn't compile, CS7036 shows\n    }\n}\n\n", "role_origin_id": "rule_RSPEC-3447", "role_id": "S3447", "role_desc": "使用参考文献或与[可选]组合使用是混淆和矛盾的.[可选]表示不必提供参数，而out和ref表示该参数将用于向调用者返回数据（ref另外表示该参数也可用于将数据传递给该方法）.因此，使它[可选]提供您将要传回方法结果的参数没有意义.实际上，编译器会引发这样的代码的错误.不幸的是，它引发了方法调用中忽略了[Optional]参数的错误，而不是问题的根源，方法声明.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass MyClass\n{\n  public void DoStuff(ref int i)\n  {\n    Console.WriteLine(i);\n  }\n\n  public static void Main()\n  {\n    var i = 42;\n    new MyClass().DoStuff(ref i); \n  }\n}\n\n", "role_level": "CRITICAL", "role_title_en": "\"[Optional]\" should not be used on \"ref\" or \"out\" parameters"},{"role_title": "不应该在覆盖上引入“params”.", "role_desc_en": "Adding params to a method override has no effect. The compiler accepts it, but the callers won't be able to benefit from the added modifier.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass Base\n{\n  public virtual void Method(int[] numbers)\n  {\n    ...\n  }\n}\nclass Derived : Base\n{\n  public override void Method(params int[] numbers) // Noncompliant, method can't be called with params syntax.\n  {\n    ...\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3600", "role_id": "S3600", "role_desc": "将参数添加到方法覆盖不起作用.编译器接受它，但调用者将无法从添加的修饰符中受益.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass Base\n{\n  public virtual void Method(int[] numbers)\n  {\n    ...\n  }\n}\nclass Derived : Base\n{\n  public override void Method(int[] numbers)\n  {\n    ...\n  }\n}\n\n", "role_level": "CRITICAL", "role_title_en": "\"params\" should not be introduced on overrides"},{"role_title": "装配应具有版本信息.", "role_desc_en": "If no AssemblyVersionAttribute is provided, the same default version will be used for every build. Since the version number is used by The .NET Framework to uniquely identify an assembly this can lead to broken dependencies.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nusing System;\nusing System.Reflection;\n\n[assembly: AssemblyTitle(\"MyAssembly\")] // Noncompliant\n\nnamespace MyLibrary\n{\n}\n\n", "role_origin_id": "rule_RSPEC-3904", "role_id": "S3904", "role_desc": "如果没有提供AssemblyVersionAttribute，则每个构建将使用相同的默认版本.由于版本号由The使用.NET框架来唯一标识一个程序集，这可能导致破坏依赖.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nusing System;\nusing System.Reflection;\n\n[assembly: AssemblyTitle(\"MyAssembly\")] \n[assembly: AssemblyVersionAttribute(\"1.2.125.0\")]\n\nnamespace MyLibrary\n{\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Assemblies should have version information"},{"role_title": "属性不应该使集合或数组复制.", "role_desc_en": "Most developers expect property access to be as efficient as field access. However, if a property returns a copy of an array or collection, it will be much slower than a simple field access, contrary to the caller's likely expectations. Therefore, such properties should be refactored into methods so that callers are not surprised by unexpectedly poor performance.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nprivate List&lt;string&gt; _foo = new List&lt;string&gt; { \"a\", \"b\", \"c\" };\npublic IEnumerable&lt;string&gt; Foo  // Noncompliant\n{ \n    get\n    {\n        return _foo.ToList(); \n    }\n}\n\nprivate string[] _bar = new string[] { \"a\", \"b\", \"c\" };\npublic IEnumerable&lt;string&gt; Bar // Noncompliant\n{ \n    get\n    {\n        return (string[])_bar.Clone(); \n    } \n}\n\n", "role_origin_id": "rule_RSPEC-2365", "role_id": "S2365", "role_desc": "大多数开发人员希望财产访问与现场访问一样高效.但是，如果一个属性返回数组或集合的副本，它将比简单的字段访问慢得多，这与调用者的可能期望相反.因此，这些属性应该被重构成方法，使得呼叫者对于意想不到的性能不感到惊讶.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nprivate List&lt;string&gt; _foo = new List&lt;string&gt; { \"a\", \"b\", \"c\" };\nprivate string[] _bar = new string[] { \"a\", \"b\", \"c\" };\n\npublic IEnumerable&lt;string&gt; GetFoo()\n{ \n    return _foo.ToList();\n}\n\npublic IEnumerable&lt;string&gt; GetBar()\n{\n    return (string[])_bar.Clone();\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Properties should not make collection or array copies"},{"role_title": "标志枚举零值成员应该命名为“无”.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\n[Flags]\nenum FruitType\n{\n    Void = 0,        // Non-Compliant\n    Banana = 1,\n    Orange = 2,\n    Strawberry = 4\n}\n\n", "role_origin_id": "rule_RSPEC-2346", "role_id": "S2346", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\n[Flags]\nenum FruitType\n{\n    None = 0,        // Compliant\n    Banana = 1,\n    Orange = 2,\n    Strawberry = 4\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Flags enumerations zero-value members should be named \"None\""},{"role_title": "不应该做不适当的演员.", "role_desc_en": "Inappropriate casts are issues that will lead to unexpected behavior or runtime errors, such as {{InvalidCastException}}s. The compiler will catch bad casts from one class to another, but not bad casts to interfaces. Nor will it catch nullable values that are known to be null but that are cast to their underlying value types anyway.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic interface IMyInterface \n{ /* ... */ }\n\npublic class Implementer : IMyInterface\n{ /* ... */ }\n\npublic class MyClass\n{ /* ... */ }\n\npublic static class Program\n{\n  public static void Main()\n  {\n    var myclass = new MyClass();\n    var x = (IMyInterface) myclass; // Noncompliant, InvalidCastException is being thrown\n    var b = myclass is IMyInterface; // Noncompliant, always false\n    \n    int? i = null;\n    var ii = (int)i; // Noncompliant, InvalidOperationException is being thrown\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-1944", "role_id": "S1944", "role_desc": "不适当的转换是导致意外行为或运行时错误的问题，例如{{InvalidCastException}}.编译器将捕获从一个类到另一个类的不良转换，但不会对接口造成不良的转换.它也不会捕获已知为null的可空值，但也将被转换为其基础值类型.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic interface IMyInterface \n{ /* ... */ }\n\npublic class Implementer : IMyInterface\n{ /* ... */ }\n\npublic class MyClass\n{ /* ... */ }\n\npublic static class Program\n{\n  public static void Main()\n  {\n    var myclass = new MyClass();\n    var x = myclass as IMyInterface; // Compliant, but will always be null\n    var b = false;\n    \n    int? i = null;\n    if (i.HasValue)\n    {\n      var ii = (int)i;\n    }\n  }\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Inappropriate casts should not be made"},{"role_title": "构造函数只应该调用不可覆盖的方法.", "role_desc_en": "Calling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the method.For example:", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Parent \n{\n  public Parent() \n  {\n    DoSomething();  // Noncompliant\n  }\n\n  public virtual void DoSomething() // can be overridden\n  {  \n    ...\n  }\n}\n\npublic class Child : Parent \n{\n  private string foo;\n\n  public Child(string foo) // leads to call DoSomething() in Parent constructor which triggers a NullReferenceException as foo has not yet been initialized\n  {\n    this.foo = foo;\n  }\n\n  public override void DoSomething() \n  {\n    Console.WriteLine(this.foo.Length);\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-1699", "role_id": "S1699", "role_desc": "从构造函数调用一个可覆盖的方法可能导致在实例化覆盖该方法的子类时出现故障或奇怪的行为.例如：.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "CRITICAL", "role_title_en": "Constructors should only call non-overridable methods"},{"role_title": "方法不应该是空的.", "role_desc_en": "There are several reasons for a method not to have a method body:", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic override void DoSomething() \n{\n}\n\npublic override void DoSomethingElse() \n{\n}\n\n", "role_origin_id": "rule_RSPEC-1186", "role_id": "S1186", "role_desc": "有一个方法没有方法体的几个原因：.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic override void DoSomething() \n{\n  // Do nothing because of X and Y.\n}\n\npublic override void DoSomethingElse() \n{\n  throw new NotSupportedException();\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Methods should not be empty"},{"role_title": "异常不应该在最后的块中抛出.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\ntry \n{\n  /* some work which end up throwing an exception */\n  throw new ArgumentException();\n} \nfinally \n{\n  /* clean up */\n  throw new InvalidOperationException();       // Noncompliant; will mask the ArgumentException\n}\n\n", "role_origin_id": "rule_RSPEC-1163", "role_id": "S1163", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\ntry\n{\n  /* some work which end up throwing an exception */\n  throw new ArgumentException();\n} \nfinally \n{\n  /* clean up */                       // Compliant\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Exceptions should not be thrown in finally blocks"},{"role_title": "实例成员不应写入“静态”字段.", "role_desc_en": "Correctly updating a static field from a non-static method is tricky to get right and could easily lead to bugs if there are multiple class instances  and/or multiple threads in play. This rule raises an issue each time a static field is updated from a non-static method or property.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class MyClass \n{\n  private static int count = 0;\n\n  public void DoSomething() \n  {\n    //...\n    count++;  // Noncompliant\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2696", "role_id": "S2696", "role_desc": "从非静态方法正确更新静态字段是很难正确的，如果有多个类实例和/或多个线程正在播放，可能容易导致错误.每次从非静态方法或属性更新静态字段时，此规则都会引发问题.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "CRITICAL", "role_title_en": "Instance members should not write to \"static\" fields"},{"role_title": "“GC.收集“不应该被调用.", "role_desc_en": "Calling GC.Collect is rarely necessary, and can significantly affect application performance. That's because it triggers a blocking operation that examines every object in memory for cleanup. Further, you don't have control over when this blocking cleanup will actually run.As a general rule, the consequences of calling this method far outweigh the benefits unless perhaps you've just triggered some event that is unique in the run of your program that caused a lot of long-lived objects to die.This rule raises an issue when GC.Collect is invoked.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nstatic void Main(string[] args)\n{\n  // ...\n  GC.Collect(2, GCCollectionMode.Optimized); // Noncompliant\n}\n\n", "role_origin_id": "rule_RSPEC-1215", "role_id": "S1215", "role_desc": "调用GC.收集很少是必要的，可以显着影响应用程序的性能.这是因为它触发了一个阻止操作来检查内存中的每个对象以进行清理.此外，您无法控制这个阻塞清理实际运行.作为一般规则，调用此方法的后果远远超过了好处，除非您刚刚触发了一些在程序运行中独一无二的事件，这些事件导致许多长命的对象死亡.这个规则引发了GC问题.收集被调用.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "CRITICAL", "role_title_en": "\"GC.Collect\" should not be called"},{"role_title": "“IndexOf”检查不应该是正数.", "role_desc_en": "Most checks against an IndexOf value compare it with -1 because 0 is a valid index. Any checks which look for values &gt;0 ignore the first element, which is likely a bug. If the intent is merely to check inclusion of a value in a string, List, or an array, consider using the Contains method instead.This rule raises an issue when an IndexOf value retrieved from a string, List, or array is tested against &gt;0.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nstring color = \"blue\";\nstring name = \"ishmael\";\n\nList&lt;string&gt; strings = new List&lt;string&gt;();\nstrings.Add(color);\nstrings.Add(name);\nstring[] stringArray = strings.ToArray();\n\nif (strings.IndexOf(color) &gt; 0) // Noncompliant\n{  \n  // ...\n}\nif (name.IndexOf(\"ish\") &gt; 0) // Noncompliant\n{ \n  // ...\n}\nif (name.IndexOf(\"ae\") &gt; 0) // Noncompliant\n{ \n  // ...\n}\nif (Array.IndexOf(stringArray, color) &gt; 0) // Noncompliant\n{  \n  // ...\n}\n\n", "role_origin_id": "rule_RSPEC-2692", "role_id": "S2692", "role_desc": "大多数针对IndexOf值的检查与-1进行比较，因为0是有效的索引.任何查找值\\u003e 0的检查都忽略第一个元素，这可能是一个错误.如果意图只是检查字符串，列表或数组中的值是否包含，请考虑使用Contains方法.当从字符串，列表或数组检索到的IndexOf值针对＆gt; 0进行测试时，此规则引发问题.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nstring color = \"blue\";\nstring name = \"ishmael\";\n\nList&lt;string&gt; strings = new List&lt;string&gt; ();\nstrings.Add(color);\nstrings.Add(name);\nstring[] stringArray = strings.ToArray();\n\nif (strings.IndexOf(color) &gt; -1) \n{\n  // ...\n}\nif (name.IndexOf(\"ish\") &gt;= 0) \n{\n  // ...\n}\nif (name.Contains(\"ae\"))\n{\n  // ...\n}\nif (Array.IndexOf(stringArray, color) &gt;= 0)\n{  \n  // ...\n}\n\n", "role_level": "CRITICAL", "role_title_en": "\"IndexOf\" checks should not be for positive numbers"},{"role_title": "“partial”方法参数名称应该匹配.", "role_desc_en": "When the parameters to the implementation of a partial method don't match those in the signature declaration, then confusion is almost guaranteed. Either the implementer was confused when he renamed, swapped or mangled the parameter names in the implementation, or callers will be confused.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npartial class Point\n{\n  partial void MoveVertically(int z);\n}\n\npartial class Point\n{\n  int x = 0;\n  int y = 0;\n  int z = 0;\n\n  partial void MoveVertically(int y)  // Noncompliant\n  {\n    this.y = y;\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-927", "role_id": "S927", "role_desc": "当执行部分方法的参数与签名声明中的参数不匹配时，几乎可以保证混淆.当实施者在实施中重命名，交换或调整参数名称时，实施者感到困惑，或者调用者将被困惑.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npartial class Point\n{\n  partial void MoveVertically(int z);\n}\n\npartial class Point\n{\n  int x = 0;\n  int y = 0;\n  int z = 0;\n\n  partial void MoveVertically(int z)\n  {\n    this.z = z;\n  }\n}\n\n", "role_level": "CRITICAL", "role_title_en": "\"partial\" method parameter names should match"},{"role_title": "认知方法的复杂性不应太高.", "role_desc_en": "Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be difficult to maintain.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-3776", "role_id": "S3776", "role_desc": "认知复杂度是衡量一种方法的控制流程要了解的程度.认知复杂性高的方法难以维持.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "CRITICAL", "role_title_en": "Cognitive Complexity of methods should not be too high"},{"role_title": "方法覆盖不应该更改参数默认值.", "role_desc_en": "Default arguments are determined by the static type of the object. If a default argument is different for a parameter in an overriding method, the value used in the call will be different when calls are made via the base or derived object, which may be contrary to developer expectations. Default parameter values are useless in explicit interface implementations, because the static type of the object will always be the implemented interface. Thus, specifying default values is useless and confusing.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Base\n{\n  public virtual void Write(int i = 42)\n  {\n    Console.WriteLine(i);\n  }\n}\n\npublic class Derived : Base\n{\n  public override void Write(int i = 5) // Noncompliant\n  {\n    Console.WriteLine(i);\n  }\n}\n\npublic class Program\n{\n  public static void Main()\n  {\n    var derived = new Derived();\n    derived.Write(); // writes 5\n    Print(derived);  // writes 42; was that expected?\n  }\n  private void Print(Base item)\n  {\n    item.Write();\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-1006", "role_id": "S1006", "role_desc": "默认参数由对象的静态类型决定.如果默认参数对于重写方法中的参数是不同的，那么当通过基础或派生对象进行调用时，调用中使用的值将不同，这可能与开发人员的期望相反.默认参数值在显式接口实现中是无用的，因为对象的静态类型将始终是实现的接口.因此，指定默认值是无用的和令人困惑的.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Base\n{\n  public virtual void Write(int i = 42)\n  {\n    Console.WriteLine(i);\n  }\n}\n\npublic class Derived : Base\n{\n  public override void Write(int i = 42)\n  {\n    Console.WriteLine(i);\n  }\n}\n\npublic class Program\n{\n  public static void Main()\n  {\n    var derived = new Derived();\n    derived.Write(); // writes 42\n    Print(derived);  // writes 42\n  }\n  private void Print(Base item)\n  {\n    item.Write();\n  }\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Method overrides should not change parameter defaults"},{"role_title": "异常类型应为“公开”.", "role_desc_en": "The point of having custom exception types is to convey more information than is available in standard types. But custom exception types must be public for that to work. If a method throws a non-public exception, the best you can do on the caller's side is to catch the closest public base of the class. That is, you lose all that custom information you created the exception type to pass. ", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\ninternal class MyException : Exception   // Noncompliant\n{\n  // ...\n}\n\n", "role_origin_id": "rule_RSPEC-3871", "role_id": "S3871", "role_desc": "具有自定义异常类型的要点是传达比标准类型可用的更多信息.但是，定制的异常类型必须是公共的才能使它工作.如果一个方法抛出一个非公开的异常，那么你可以在调用者方面做的最好的事情就是抓住类的最接近的公共基础.也就是说，您将丢失创建的异常类型的所有自定义信息.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class MyException : Exception\n{\n  // ...\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Exception types should be \"public\""},{"role_title": "场景事件不应该是虚拟的.", "role_desc_en": "Field-like events are events that do not have explicit add and remove methods. The compiler generates a private delegate field to back the event, as well as generating the implicit add and remove methods.When a virtual field-like event is overridden by another field-like event, the behavior of the C# compiler is to generate a new private delegate field in the derived class, separate from the parent's field. This results in multiple and separate events being created, which is rarely what's actually intended.To prevent this, remove the virtual designation from the parent class event.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nabstract class Car\n{\n  public virtual event EventHandler OnRefueled; // Noncompliant\n\n  public void Refuel()\n  {\n    // This OnRefueld will always be null\n     if (OnRefueled != null)\n     {\n       OnRefueled(this, null);\n     }\n  }\n}\n\nclass R2 : Car\n{\n  public override event EventHandler OnRefueled;\n}\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    var r2 = new R2();\n    r2.OnRefueled += new EventHandler((o, a) =&gt;\n    {\n      Console.WriteLine(\"This event will never be called\");\n    });\n    r2.Refuel();\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2290", "role_id": "S2290", "role_desc": "场类事件是没有显式添加和删除方法的事件.编译器生成一个专用委托字段来备份事件，并生成隐式的add和remove方法.当类似虚拟场景的事件被另一个类似场景的事件覆盖时，C＃编译器的行为是在派生类中生成一个新的专用委托字段，与父字段不同.这将导致创建多个单独的事件，这很少是实际意图.为了防止这种情况，请从父类事件中删除虚拟名称.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nabstract class Car\n{\n  public event EventHandler OnRefueled; // Compliant\n\n  public void Refuel()\n  {\n    if (OnRefueled != null)\n    {\n      OnRefueled(this, null);\n    }\n  }\n}\n\nclass R2 : Car {}\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    var r2 = new R2();\n    r2.OnRefueled += new EventHandler((o, a) =&gt;\n    {\n      Console.WriteLine(\"This event will be called\");\n    });\n    r2.Refuel();\n  }\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Field-like events should not be virtual"},{"role_title": "内部类成员不应该影响外部类“静态”或类型成员.", "role_desc_en": "It's possible to name the members of an inner class the same as the static members of its enclosing class - possible, but a bad idea. That's because maintainers may be confused about which members are being used where. Instead the inner class' members should be renamed and all the references updated.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass Outer\n{\n  public static int A;\n\n  public class Inner\n  {\n    public int A; //Noncompliant\n    public int MyProp\n    {\n      get { return A; }  // Returns inner A. Was that intended?\n    }\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3218", "role_id": "S3218", "role_desc": "可以将内部类的成员命名为它的包围类的静态成员 - 可能，但是一个坏主意.这是因为维护者可能会将哪些成员在哪里使用而感到困惑.而应该重命名内部类的成员，并更新所有的引用.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass Outer\n{\n  public static int A;\n\n  public class Inner\n  {\n    public int InnerA;\n    public int MyProp\n    {\n      get { return InnerA; }\n    }\n  }\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Inner class members should not shadow outer class \"static\" or type members"},{"role_title": "非常数静态字段不可见.", "role_desc_en": "A static field that is neither constant nor read-only is not thread-safe. Correctly accessing these fields from different threads needs synchronization with lock}}s. Improper synchronization may lead to unexpected results, thus publicly visible static fields are best suited for storing non-changing data shared by many consumers. To enforce this intent, these fields should be marked {{readonly or converted to constants.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Math\n{\n  public static double Pi = 3.14;  // Noncompliant\n} \n\n", "role_origin_id": "rule_RSPEC-2223", "role_id": "S2223", "role_desc": "既不是常量也不是只读的静态字段不是线程安全的.正确地从不同的线程访问这些字段需要与lock}}同步.不正确的同步可能导致意想不到的结果，因此公开可见的静态字段最适合于存储许多消费者共享的不变数据.为了实现这个意图，这些字段应该被标记为{{只读或转换为常量.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Math\n{\n  public const double Pi = 3.14;\n} \n\n", "role_level": "CRITICAL", "role_title_en": "Non-constant static fields should not be visible"},{"role_title": "非标记枚举不应该用于按位操作.", "role_desc_en": "enum}}s are usually used to identify distinct elements in a set of values. However {{enum}}s can be treated as bit fields and bitwise operations can be used on them to combine the values. This is a good way of specifying multiple elements of set with a single value. When {{enum}}s are used this way, it is a best practice to mark the {{enum with the FlagsAttribute.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nenum Permissions\n{ \n  None = 0,\n  Read = 1,   \n  Write = 2, \n  Execute = 4 \n}\n// ...\n\nvar x = Permissions.Read | Permissions.Write;  // Noncompliant; enum is not marked with [Flags]\n\n", "role_origin_id": "rule_RSPEC-3265", "role_id": "S3265", "role_desc": "枚举}}通常用于标识一组值中的不同元素.然而，{{enum}}可以被视为位字段，并且可以使用按位操作来组合这些值.当这样使用{{enum}}时，最好将标记为{{枚举的FlagsAttribute.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\n[Flags]\nenum Permissions\n{ \n  None = 0,\n  Read = 1, \n  Write = 2, \n  Execute = 4\n}\n// ...\n\nvar x = Permissions.Read | Permissions.Write;\n\n", "role_level": "CRITICAL", "role_title_en": "Non-flags enums should not be used in bitwise operations"},{"role_title": "“Enumerable”不能禁用溢出检查.和”.", "role_desc_en": "Enumerable.Sum() always executes addition in a checked context, so an OverflowException will be thrown if the value exceeds MaxValue even if an unchecked context was specified. Using an unchecked context anyway represents a misunderstanding of how Sum works.This rule raises an issue when an unchecked context is specified for a Sum on integer types.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvoid Add(List&lt;int&gt; list)\n{\n  int d = unchecked(list.Sum());  // Noncompliant\n\n  unchecked \n  {\n    int e = list.Sum();  // Noncompliant\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2291", "role_id": "S2291", "role_desc": "枚举.Sum（）总是在检查的上下文中执行添加，因此即使指定了未检查的上下文，如果该值超过MaxValue，则抛出OverflowException.无论如何使用未经检查的上下文表示对于Sum如何工作的误解.当为整数类型的Sum指定未检查的上下文时，此规则引发问题.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvoid Add(List&lt;int&gt; list)\n{\n  int d = list.Sum();\n\n  try \n  {\n    int e = list.Sum();\n  } \n  catch (System.OverflowException e) \n  {\n    // exception handling...\n  }\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Overflow checking should not be disabled for \"Enumerable.Sum\""},{"role_title": "移位操作符的右操作数应为整数.", "role_desc_en": "Numbers can be shifted with the &lt;&lt; and &gt;&gt; operators, but the right operand of the operation needs to be an int or a type that has an implicit conversion to int. However, with dynamic, the compiler's type checking is turned off, so you can pass anything to a shift operator and have it compile. And if  the argument can't be converted to int at runtime, then a RuntimeBinderException will be raised.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\ndynamic d = 5;\nvar x = d &gt;&gt; 5.4; // Noncompliant\nx = d &gt;&gt; null; // Noncompliant\nx &lt;&lt;= new object(); // Noncompliant\n\n", "role_origin_id": "rule_RSPEC-3449", "role_id": "S3449", "role_desc": "数字可以与＆lt;.但是，使用动态方法，编译器的类型检查将被关闭，因此您可以将任何内容传递给移位运算符并进行编译.并且如果参数在运行时无法转换为int，则会引发RuntimeBinderException.", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "CRITICAL", "role_title_en": "Right operands of shift operators should be integers"},