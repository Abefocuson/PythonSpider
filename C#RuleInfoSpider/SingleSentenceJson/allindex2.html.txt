{"role_title": "不应该使用“= +”而不是“+ =”.", "role_desc_en": "The use of operators pairs ( =+, =- or =Unable to render embedded object: File (}} ) where the reversed, single operator was meant ({{+=}}, {{-=}} or {{) not found.=) will compile and run, but not produce the expected results.This rule raises an issue when =+, =-, or =! is used without any spacing between the two operators and when there is at least one whitespace character after.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nint target = -5;\nint num = 3;\n\ntarget =- num;  // Noncompliant; target = -3. Is that really what's meant?\ntarget =+ num; // Noncompliant; target = 3\n\n", "role_origin_id": "rule_RSPEC-2757", "role_id": "S2757", "role_desc": "使用反转的单个运算符（{{+ =}}，{{ -  =}}或{{）可以使用运算符对（= +，=  - 或=无法呈现嵌入对象：File（}.=）将编译并运行，但不会产生预期的结果.当= +，=  - 或=！时，此规则引发问题。.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nint target = -5;\nint num = 3;\n\ntarget = -num;  // Compliant; intent to assign inverse value of num is clear\ntarget += num;\n\n", "role_level": "MAJOR", "role_title_en": "\"=+\" should not be used instead of \"+=\""},{"role_title": "“部件.应使用“负载”.", "role_desc_en": "The parameter to Assembly.Load includes the full specification of the dll to be loaded. Use another method, and you might end up with a dll other than the one you expected. This rule raises an issue when Assembly.LoadFrom, Assembly.LoadFile, or Assembly.LoadWithPartialName is called.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nstatic void Main(string[] args)\n{\n    Assembly.LoadFrom(...); // Noncompliant\n    Assembly.LoadFile(...); // Noncompliant\n    Assembly.LoadWithPartialName(...); // Noncompliant + deprecated\n}\n\n", "role_origin_id": "rule_RSPEC-3885", "role_id": "S3885", "role_desc": "装配参数.负载包括要加载的dll的完整规范.使用另一种方法，你可能会遇到一个不同于你预期的DLL.这个规则在汇编时提出了一个问题.LoadFrom，装配.LoadFile或Assembly.LoadWithPartialName被调用.", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "\"Assembly.Load\" should be used"},{"role_title": "“GC.SuppressFinalize“不应该被调用.", "role_desc_en": "GC.SuppressFinalize requests that the system not call the finalizer for the specified object. This should only be done when implementing Dispose as part of the Dispose Pattern.\nThis rule raises an issue when GC.SuppressFinalize is called outside that pattern.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-3971", "role_id": "S3971", "role_desc": "GC.SuppressFinalize请求系统不调用指定对象的终结器.这只能在Dispose作为Dispose Pattern的一部分实现时完成.这个规则引发了GC问题.SuppressFinalize在该模式之外被调用.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "\"GC.SuppressFinalize\" should not be called"},{"role_title": "“IDisposable”应该正确实现.", "role_desc_en": "The IDisposable interface is a mechanism to release unmanaged resources, if not implemented correctly this could result in resource leaks or more severe bugs.This rule raises an issue when the recommended dispose pattern, as defined by Microsoft, is not adhered to. See the Compliant Solution section for examples.Satisfying the rule's conditions will enable potential derived classes to correctly dispose the members of your class:", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Foo1 : IDisposable // Noncompliant - provide protected overridable implementation of Dispose(bool) on Foo or mark the type as sealed.\n{\n    public void Dispose() // Noncompliant - should contain only a call to Dispose(true) and then GC.SuppressFinalize(this)\n    {\n        // Cleanup\n    }\n}\n\npublic class Foo2 : IDisposable\n{\n    void IDisposable.Dispose() // Noncompliant - Dispose() should be public\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    public virtual void Dispose() // Noncompliant - Dispose() should be sealed\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n}\n\npublic class Foo3 : IDisposable\n{\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        // Cleanup\n    }\n\n    ~Foo3() // Noncompliant - Modify Foo.~Foo() so that it calls Dispose(false) and then returns.\n    {\n        // Cleanup\n    }\n}\n", "role_origin_id": "rule_RSPEC-3881", "role_id": "S3881", "role_desc": "IDisposable接口是一种释放非托管资源的机制，如果未正确实现，可能会导致资源泄漏或更严重的错误.当不遵守由Microsoft定义的推荐处置模式时，此规则引发问题.有关示例，请参阅兼容性解决方案部分.满足规则的条件将使得潜在的派生类能够正确地处理您的课程成员：.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\n// Sealed class\npublic sealed class Foo1 : IDisposable\n{\n    public void Dispose()\n    {\n        // Cleanup\n    }\n}\n\n// Simple implementation\npublic class Foo2 : IDisposable\n{\n    public void Dispose()\n    {\n        Dispose(true);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        // Cleanup\n    }\n}\n\n// Implementation with a finalizer\npublic class Foo3 : IDisposable\n{\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        // Cleanup\n    }\n\n    ~Foo3()\n    {\n        Dispose(false);\n    }\n}\n\n// Base disposable class\npublic class Foo4 : DisposableBase\n{\n    protected override void Dispose(bool disposing)\n    {\n        // Cleanup\n        // Do not forget to call base\n        base.Dispose(disposing);\n    }\n}\n\n", "role_level": "MAJOR", "role_title_en": "\"IDisposable\" should be implemented correctly"},{"role_title": "不能返回在“using”语句中创建的“IDisposables”.", "role_desc_en": "Typically you want to use using to create a local IDisposable variable; it will trigger disposal of the object when control passes out of the block's scope. The exception to this rule is when your method returns that IDisposable. In that case using disposes of the object before the caller can make use of it, likely causing exceptions at runtime. So you should either remove using or avoid returning the IDisposable.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic FileStream WriteToFile(string path, string text)\n{\n  using (var fs = File.Create(path)) // Noncompliant\n  {\n    var bytes = Encoding.UTF8.GetBytes(text);\n    fs.Write(bytes, 0, bytes.Length);\n    return fs; \n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2997", "role_id": "S2997", "role_desc": "通常你想使用使用来创建一个本地的IDisposable变量;.此规则的例外是当您的方法返回该IDisposable.在这种情况下，在调用者可以使用它之前使用对象的配置，可能在运行时引起异常.所以你应该删除使用或避免返回IDisposable.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic FileStream WriteToFile(string path, string text)\n{\n  var fs = File.Create(path);\n  var bytes = Encoding.UTF8.GetBytes(text);\n  fs.Write(bytes, 0, bytes.Length);\n  return fs;\n}\n\n", "role_level": "MAJOR", "role_title_en": "\"IDisposables\" created in a \"using\" statement should not be returned"},{"role_title": "“IEnumerable”应该简化LINQ.", "role_desc_en": "In the interests of readability, code that can be simplified should be simplified. To that end, there are several ways {{IEnumerable LINQ}}s can be simplified", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nseq1.Select(element =&gt; element as T).Any(element =&gt; element != null);  // Noncompliant; use OfType\nseq2.Select(element =&gt; element as T).Any(element =&gt; element != null &amp;&amp; CheckCondition(element));  // Noncompliant; use OfType\nseq3.Where(element =&gt; element is T).Select(element =&gt; element as T); // Noncompliant; use OfType\nseq4.Where(element =&gt; element is T).Select(element =&gt; (T)element); // Noncompliant; use OfType\nseq5.Where(element =&gt; [expression]).Any();  // Noncompliant; use Any([expression])\n\nvar num = seq6.Count(); // Noncompliant\nvar arr = seq.ToList().ToArray(); //Noncompliant\nvar count = seq.ToList().Count(x=&gt;[condition]); //Noncompliant\n\n", "role_origin_id": "rule_RSPEC-2971", "role_id": "S2971", "role_desc": "为了可读性，可以简化可以简化的代码.为此，可以简化{{IEnumerable LINQ}}的几种方式.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nseq1.OfType&lt;T&gt;().Any();\nseq2.OfType&lt;T&gt;().Any(element =&gt; CheckCondition(element));\nseq3.OfType&lt;T&gt;();\nseq4.OfType&lt;T&gt;();\nseq5.Any(element =&gt; [expression])\n\nvar num = seq6.Count;\nvar arr = seq.ToArray();\nvar count = seq.Count(x=&gt;[condition]); \n\n", "role_level": "MAJOR", "role_title_en": "\"IEnumerable\" LINQs should be simplified"},{"role_title": "“目的.ReferenceEquals“不应用于值类型.", "role_desc_en": "Using Object.ReferenceEquals to compare the references of two value types simply won't return the expected results most of the time because such types are passed by value, not by reference.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class MyClass\n{\n  private MyStruct myStruct;\n\n  public void DoSomething(MyStruct s1) {\n    int a = 1;\n    int b = 1;\n\n    if (Object.ReferenceEquals(myStruct, s1))  // Noncompliant; this can never be true\n    {\n      // ...\n    }\n    else if (Object.ReferenceEquals(a,b)) // Noncompliant\n    {\n      // ...\n    }\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2995", "role_id": "S2995", "role_desc": "使用对象.比较两个值类型的引用的ReferenceEquals根本不会返回大多数时间的预期结果，因为这些类型是通过值传递的，而不是通过引用.", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "\"Object.ReferenceEquals\" should not be used for value types"},{"role_title": "应该使用“ServiceContract”和“OperationContract”属性.", "role_desc_en": "The ServiceContract attribute specifies that a class or interface defines the communication contract of a Windows Communication Foundation (WCF) service. The service operations of this class or interface are defined by OperationContract attributes added to methods. It doesn't make sense to define a contract without any service operations; thus, in a ServiceContract class or interface at least one method should be annotated with OperationContract. Similarly, WCF only serves OperationContract methods that are defined inside ServiceContract classes or interfaces; thus, this rule also checks that ServiceContract is added to the containing type of OperationContract methods.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\n[ServiceContract]\ninterface IMyService // Noncompliant\n{\n  int MyServiceMethod();\n}\n\n", "role_origin_id": "rule_RSPEC-3597", "role_id": "S3597", "role_desc": "ServiceContract属性指定类或接口定义Windows Communication Foundation（WCF）服务的通信合同.此类或接口的服务操作由添加到方法的OperationContract属性定义.在没有任何服务操作的情况下定义合同是没有意义的;.类似地，WCF仅提供在ServiceContract类或接口中定义的OperationContract方法;.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\n[ServiceContract]\ninterface IMyService\n{\n  [OperationContract]\n  int MyServiceMethod();\n}\n\n", "role_level": "MAJOR", "role_title_en": "\"ServiceContract\" and \"OperationContract\" attributes should be used together"},{"role_title": "“ThreadStatic”字段不应该被初始化.", "role_desc_en": "When an object has a field annotated with ThreadStatic, that field is shared within a given thread, but unique across threads. Since a class' static initializer is only invoked for the first thread created, it also means that only the first thread will have the expected initial values.Instead, allow such fields to be initialized to their default values or make the initialization lazy.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Foo\n{\n  [ThreadStatic]\n  public static object PerThreadObject = new object(); // Noncompliant. Will be null in all the threads except the first one.\n}\n\n", "role_origin_id": "rule_RSPEC-2996", "role_id": "S2996", "role_desc": "当一个对象具有使用ThreadStatic注释的字段时，该字段在给定的线程内共享，但在线程之间是唯一的.由于只为第一个线程创建了一个静态初始值类，所以这也意味着只有第一个线程将具有预期的初始值.相反，允许将这些字段初始化为其默认值或使初始化懒惰.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Foo\n{\n  [ThreadStatic]\n  public static object _perThreadObject;\n  public static object PerThreadObject \n  {\n    get \n    {\n      if (_perThreadObject == null) \n      {\n        _perThreadObject = new object();\n      }\n      return _perThreadObject;\n    }\n  }\n}\n\n", "role_level": "MAJOR", "role_title_en": "\"ThreadStatic\" fields should not be initialized"},{"role_title": "不应该在非静态字段上使用“ThreadStatic”.", "role_desc_en": "When a non-static class field is annotated with ThreadStatic, the code seems to show that the field can have different values for different calling threads, but that's not the case, since the ThreadStatic attribute is simply ignored on non-static fields. So ThreadStatic should either be removed or replaced with a use of the ThreadLocal&lt;T&gt; class, which gives a similar behavior for non-static fields.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class MyClass \n{\n  [ThreadStatic]  // Noncompliant\n  private int count = 0;\n\n  // ...\n}\n\n", "role_origin_id": "rule_RSPEC-3005", "role_id": "S3005", "role_desc": "当使用ThreadStatic注释非静态类字段时，代码似乎表明该字段对于不同的调用线程可以具有不同的值，但事实并非如此，因为ThreadStatic属性在非静态字段上被简单地忽略.所以ThreadStatic应该被使用ThreadLocal＆lt; T＆gt;.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class MyClass \n{\n  private int count = 0;\n\n  // ...\n}\n\n", "role_level": "MAJOR", "role_title_en": "\"ThreadStatic\" should not be used on non-static fields"},{"role_title": "“抽象”类不应该有“公共”构造函数.", "role_desc_en": "Since abstract classes can't be instantiated, there's no point in their having public or internal constructors. If there is basic initialization logic that should run when an extending class instance is created, you can by all means put it in a constructor, but make that constructor private or protected.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nabstract class Base\n{\n    public Base() // Noncompliant, should be private or protected\n    {\n      //...\n    }\n}\n\n", "role_origin_id": "rule_RSPEC-3442", "role_id": "S3442", "role_desc": "由于抽象类不能被实例化，所以他们有公共或内部构造函数没有任何意义.如果有一个基本的初始化逻辑应该在扩展类实例被创建的时候运行，你可以通过一切手段把它放在一个构造函数中，但是使该构造函数是私有或受保护的.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nabstract class Base\n{\n    protected Base()\n    {\n      //...\n    }\n}\n\n", "role_level": "MAJOR", "role_title_en": "\"abstract\" classes should not have \"public\" constructors"},{"role_title": "“异步”方法不应该返回“void”.", "role_desc_en": "An async method with a void return type is a \"fire and forget\" method best reserved for event handlers because there's no way to wait for the method's execution to complete and respond accordingly. There's also no way to catch exceptions thrown from the method.Having an async void method that is not an event handler could mean your program works some times and not others because of timing issues. Instead, async methods should return Task.This rule raises an issue when non-event handler methods are both async and void.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass HttpPrinter\n{\n  private string content;\n\n  public async void CallNetwork(string url) //Noncompliant\n  {\n    var client = new HttpClient();\n    var response = await client.GetAsync(url);\n    content = await response.Content.ReadAsStringAsync();\n  }\n\n  public async Task PrintContent(string url)  // works correctly if web request finishes in under 1 second, otherwise content will be null\n  {\n    CallNetwork(url);\n    await Task.Delay(1000);\n    Console.Write(content);\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3168", "role_id": "S3168", "role_desc": "具有void返回类型的异步方法是对事件处理程序最好的“fire and forget”方法，因为无法等待方法的执行完成并相应地进行响应.也没有办法捕获从方法抛出的异常.使用不是事件处理程序的异步void方法可能意味着您的程序可以工作一些时间，而不是其他因为时序问题.相反，异步方法应该返回任务.当非事件处理程序方法都是async和void时，此规则引发了一个问题.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass HttpPrinter\n{\n  private string content;\n\n  public async Task CallNetwork(string url)\n  {\n    var client = new HttpClient();\n    var response = await client.GetAsync(url);\n    content = await response.Content.ReadAsStringAsync();\n  }\n\n  public async Task PrintContent(string url)\n  {\n    await CallNetwork(url); // &lt;----- call changed here. If await is not added warning CS4014 will be triggered\n    await Task.Delay(1000);\n    Console.Write(content);\n  }\n}\n\n", "role_level": "MAJOR", "role_title_en": "\"async\" methods should not return \"void\""},{"role_title": "“goto”语句不应该被使用.", "role_desc_en": "goto is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such as if, for, while, continue or break should be used instead.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-907", "role_id": "S907", "role_desc": "goto是一个非结构化的控制流程语句.它使代码的可读性和可维护性降低.应使用结构化控制流程语句（如if，for，while，continue或break）.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "\"goto\" statement should not be used"},{"role_title": "“params”应该用于覆盖.", "role_desc_en": "Overriding methods automatically inherit the params behavior. To ease readability, this modifier should be explicitly used in the overriding method as well.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass Base\n{\n  public virtual void Method(params int[] numbers)\n  {\n    ...\n  }\n}\nclass Derived : Base\n{\n  public override void Method(int[] numbers) // Noncompliant, the params is missing.\n  {\n    ...\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3262", "role_id": "S3262", "role_desc": "覆盖方法会自动继承params行为.为了简化可读性，此修饰符也应该在覆盖方法中明确使用.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass Base\n{\n  public virtual void Method(params int[] numbers)\n  {\n    ...\n  }\n}\nclass Derived : Base\n{\n  public override void Method(params int[] numbers)\n  {\n    ...\n  }\n}\n\n", "role_level": "MAJOR", "role_title_en": "\"params\" should be used on overrides"},{"role_title": "匿名代表不应该被用来取消订阅事件.", "role_desc_en": "It is possible to subscribe to events with anonymous delegates, but having done so, it is impossible to unsubscribe from them. That's because the process of subscribing adds the delegate to a list. The process of unsubscribing essentially says: remove this item from the subscription list. But because an anonymous delegate was used in both cases, the unsubscribe attempt tries to remove a different item from the list than was added. The result: NOOP.Instead, save the delegate to a variable and use the variable to subscribe and unsubscribe.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nlistView.PreviewTextInput += (obj,args) =&gt;\n        listView_PreviewTextInput(obj,args,listView);  \n\n// ...\n\nlistView.PreviewTextInput -= (obj, args) =&gt; \n        listView_PreviewTextInput(obj, args, listView); // Noncompliant; this delegate was never subscribed\n\n", "role_origin_id": "rule_RSPEC-3244", "role_id": "S3244", "role_desc": "可以使用匿名代表订阅事件，但是这样做是不可能取消订阅的.这是因为订阅过程将委托添加到列表中.取消订阅的过程基本上说：从订阅列表中删除此项.但是因为在这两种情况下都使用了匿名委托，所以取消订阅的尝试会尝试从列表中删除与添加的不同的项目.结果：NOOP.相反，将代理保存到变量中，并使用该变量来订阅和取消订阅.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nEventHandler func = (obj,args) =&gt; listView_PreviewTextInput(obj,args,listView);\n\nlistView.PreviewTextInput += func;\n\n// ...\n\nlistView.PreviewTextInput -= func;\n\n", "role_level": "MAJOR", "role_title_en": "Anonymous delegates should not be used to unsubscribe from Events"},{"role_title": "静态字段不应该在构造函数中更新.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Person \n{\n  private static DateTime dateOfBirth;\n  private static int expectedFingers;\n\n  public Person(DateTime birthday) \n  {\n    dateOfBirth = birthday;  // Noncompliant; now everyone has this birthday\n    expectedFingers = 10;  // Noncompliant\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3010", "role_id": "S3010", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Person \n{\n  private DateTime dateOfBirth;\n  private static int expectedFingers = 10;\n\n  public Person(DateTime birthday) \n  {\n    this.dateOfBirth = birthday;\n  }\n}\n\n", "role_level": "MAJOR", "role_title_en": "Static fields should not be updated in constructors"},{"role_title": "不管条件如何，三元运算符都不应该返回相同的值.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic bool CanVote(Person person) \n{\n  return person.GetAge() &gt; 18 ? true : true; // Noncompliant; is this what was intended?\n}\n\n", "role_origin_id": "rule_RSPEC-2758", "role_id": "S2758", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic bool CanVote(Person person) \n{\n  return person.GetAge() &gt; 18 ? true : false; \n  // or even better: \n  // return person.GetAge() &gt; 18;\n}\n\n", "role_level": "MAJOR", "role_title_en": "The ternary operator should not return the same value regardless of the condition"},{"role_title": "“NaN”不应该用于比较.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvar a = double.NaN;\n\nif (a == double.NaN) // Noncompliant; always false\n{\n  Console.WriteLine(\"a is not a number\");  // this is dead code\n}\nif (a != double.NaN)  // Noncompliant; always true\n{\n  Console.WriteLine(\"a is not NaN\"); // this statement is not necessarily true\n}\n\n", "role_origin_id": "rule_RSPEC-2688", "role_id": "S2688", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif (double.IsNaN(a)) \n{\n  console.log(\"a is not a number\");\n}\n\n", "role_level": "MAJOR", "role_title_en": "\"NaN\" should not be used in comparisons"},{"role_title": "多列块应用大括号括起来.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (condition)\n  FirstActionInBlock();\n  SecondAction();  // Noncompliant; executed unconditionally\nThirdAction();\n\nif(condition) FirstActionInBlock(); SecondAction();  // Noncompliant; secondAction executed unconditionally\n\nif(condition) FirstActionInBlock();  // Noncompliant\n  SecondAction();  // Executed unconditionally\n\nstring str = null;\nfor (int i = 0; i &lt; array.Length; i++) \n  str = array[i];\n  DoTheThing(str);  // Noncompliant; executed only on last array element\n\n", "role_origin_id": "rule_RSPEC-2681", "role_id": "S2681", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif (condition) \n{\n  FirstActionInBlock();\n  SecondAction();\n}\nThirdAction();\n\nstring str = null;\nfor (int i = 0; i &lt; array.Length; i++) \n{\n  str = array[i];\n  DoTheThing(str);\n}\n\n", "role_level": "MAJOR", "role_title_en": "Multiline blocks should be enclosed in curly braces"},{"role_title": "布尔表达式不应该是无偿的.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\na = true;\nif (a) // Noncompliant\n{\n  DoSomething();\n}\n\nif (b &amp;&amp; a) // Noncompliant; \"a\" is always \"true\"\n{\n  DoSomething();\n}\n\nif (c || !a) // Noncompliant; \"!a\" is always \"false\"\n{\n  DoSomething();\n}\n\n", "role_origin_id": "rule_RSPEC-2589", "role_id": "S2589", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\na = true;\nif (Foo(a))\n{\n  DoSomething();\n}\n\nif (b)\n{\n  DoSomething();\n}\n\nif (c)\n{\n  DoSomething();\n}\n\n", "role_level": "MAJOR", "role_title_en": "Boolean expressions should not be gratuitous"},{"role_title": "有条件执行的块应该是可达到的.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\na = false;\nif (a) // Noncompliant\n{\n  DoSomething(); // never executed\n}\n\nif (!a || b) // Noncompliant; \"!a\" is always \"true\", \"b\" is never evaluated\n{\n  DoSomething();\n}\nelse\n{\n  DoSomethingElse(); // never executed\n}\n\n", "role_origin_id": "rule_RSPEC-2583", "role_id": "S2583", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Conditionally executed blocks should be reachable"},{"role_title": "不要使用只写属性.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass Program\n{\n    public int Foo  //Non-Compliant\n    {\n        set\n        {\n            // ... some code ...\n        }\n    }\n}\n\n", "role_origin_id": "rule_RSPEC-2376", "role_id": "S2376", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass Program\n{\n    private int foo;\n\n    public void SetFoo(int value)\n    {\n        // ... some code ...\n        foo = value;\n    }\n}\n\n", "role_level": "MAJOR", "role_title_en": "Write-only properties should not be used"},{"role_title": "不应该从物业吸引者抛出例外.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic int Foo\n{\n  get\n  {\n    throw new Exception(); // Noncompliant\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2372", "role_id": "S2372", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Exceptions should not be thrown from property getters"},{"role_title": "空指针不应该被取消引用.", "role_desc_en": "A reference to null should never be dereferenced/accessed. Doing so will cause a NullReferenceException to be thrown. At best, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would be useful to an attacker, or it could allow an attacker to bypass security measures.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nobject o = null;\nif (condition)\n{\n  M1(o.ToString()); // Noncompliant, always null\n}\nelse\n{\n  o = new object();\n}\nM2(o.ToString());\n\n", "role_origin_id": "rule_RSPEC-2259", "role_id": "S2259", "role_desc": "不应该引用/访问对null的引用.这样做会导致抛出NullReferenceException.最好的是，这样的例外会导致程序终止.最糟糕的是，它可能暴露对攻击者有用的调试信息，或者可能允许攻击者绕过安全措施.", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Null pointers should not be dereferenced"},{"role_title": "参数应以正确的顺序传递.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic double Divide(int divisor, int dividend) \n{\n  return divisor/dividend;\n}\n\npublic void DoTheThing() \n{\n  int divisor = 15;\n  int dividend = 5;\n\n  double result = Divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected\n  //...\n}\n\n", "role_origin_id": "rule_RSPEC-2234", "role_id": "S2234", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic double Divide(int divisor, int dividend) \n{\n  return divisor/dividend;\n}\n\npublic void DoTheThing() \n{\n  int divisor = 15;\n  int dividend = 5;\n\n  double result = Divide(divisor, dividend);\n  //...\n}\n\n", "role_level": "MAJOR", "role_title_en": "Parameters should be passed in the correct order"},{"role_title": "当函数调用没有任何副作用时，不应忽略返回值.", "role_desc_en": "When the call to a function doesn't have any side effects, what is the point of making the call if the results are ignored? In such case, either the function call is useless and should be dropped or the source code doesn't behave as expected.This rule raises an issue when the results of the following methods are ignored:", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\ncoll.Where(i =&gt; i &gt; 5).Select(i =&gt; i*i); // Noncompliant\n\"this string\".Equals(\"other string\"); // Noncompliant\n\n", "role_origin_id": "rule_RSPEC-2201", "role_id": "S2201", "role_desc": "当对功能的调用没有任何副作用时，如果忽略结果，拨打电话的要点是什么？.当忽略以下方法的结果时，此规则引发了一个问题：.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvar res = coll.Where(i =&gt; i &gt; 5).Select(i =&gt; i*i);\nvar isEqual = \"this string\".Equals(\"other string\");\n\n", "role_level": "MAJOR", "role_title_en": "Return values should not be ignored when function calls don't have any side effects"},{"role_title": "价值观不应该无谓地增加.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic int PickNumber()\n{\n  int i = 0;\n  int j = 0;\n\n  i = i++; // Noncompliant; i is still zero\n\n  return j++; // Noncompliant; 0 returned\n}\n\n", "role_origin_id": "rule_RSPEC-2123", "role_id": "S2123", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic int PickNumber()\n{\n  int i = 0;\n  int j = 0;\n\n  i++; \n  return ++j; \n}\n\n", "role_level": "MAJOR", "role_title_en": "Values should not be uselessly incremented"},{"role_title": "条件结构中的两个分支不应该具有完全相同的实现.", "role_desc_en": "Having two cases in the same switch statement or branches in the same if structure with the same implementation is at best duplicate code, and at worst a coding error. If the same logic is truly needed for both instances, then in an if structure they should be combined, or for a switch, one should fall  through to the other.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nswitch (i)\n{\n  case 1:\n    DoSomething();\n    break;\n  case 2:\n    DoSomethingDifferent();\n    break;\n  case 3:  // Noncompliant; duplicates case 1's implementation\n    DoSomething();\n    break;\n  default:\n    DoTheRest();\n}\n\nif (a &gt;= 0 &amp;&amp; a &lt; 10)\n{\n  DoTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20)\n{\n  DoTheOtherThing();\n}\nelse if (a &gt;= 20 &amp;&amp; a &lt; 50)\n{\n  DoTheThing();  // Noncompliant; duplicates first condition\n}\nelse\n{\n  DoTheRest();\n}\n\nif (b == 0)\n{\n  DoOneMoreThing();\n}\n\n", "role_origin_id": "rule_RSPEC-1871", "role_id": "S1871", "role_desc": "在相同的switch语句中有两种情况或相同的if结构中具有相同实现的分支是最多的重复代码，最糟糕的是编码错误.如果两个实例都需要相同的逻辑，那么在if结构中，它们应该被组合，或者对于一个交换机，应该通过另一个.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nswitch (i) {\n  case 1:\n  case 3:\n    DoSomething();\n    break;\n  case 2:\n    DoSomethingDifferent();\n    break;\n  default:\n    DoTheRest();\n}\n\nif ((a &gt;= 0 &amp;&amp; a &lt; 10) || (a &gt;= 20 &amp;&amp; a &lt; 50))\n{\n  DoTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20)\n{\n  DoTheOtherThing();\n}\nelse\n{\n  DoTheRest();\n}\n\nDoOneMoreThing();\n\n", "role_level": "MAJOR", "role_title_en": "Two branches in a conditional structure should not have exactly the same implementation"},{"role_title": "相关的“if / else if”语句不应该有相同的条件.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (param == 1)\n{\n  OpenWindow();\n}\nelse if (param == 2)\n{\n  CloseWindow();\n}\nelse if (param == 1) // Noncompliant\n{\n  MoveWindowToTheBackground();\n}\n\n", "role_origin_id": "rule_RSPEC-1862", "role_id": "S1862", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif (param == 1)\n{\n  OpenWindow();\n}\nelse if (param == 2)\n{\n  CloseWindow();\n}\nelse if (param == 3)\n{\n  MoveWindowToTheBackground();\n}\n\n", "role_level": "MAJOR", "role_title_en": "Related \"if/else if\" statements should not have the same condition"},{"role_title": "应该删除死店.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvoid CalculateRate(int a, int b)\n{\n  int i;\n  \n  i = a + b; // Noncompliant; calculation result not used before value is overwritten\n  i = DoSomething();  // Noncompliant; retrieved value not used\n  for (i = 0; i &lt; 10; i++) \n  { \n    //  ...\n  }\n  // ...\n}\n\n", "role_origin_id": "rule_RSPEC-1854", "role_id": "S1854", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvoid CalculateRate(int a, int b)\n{\n  int i;\n\n  i = DoSomething();\n  i += a + b;\n  StoreI(i);\n\n  for (i = 0; i &lt; 10; i++) \n  { \n    //  ...\n  }\n}\n\n", "role_level": "MAJOR", "role_title_en": "Dead stores should be removed"},{"role_title": "对象不应该被创建为立即被丢弃而不使用.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (x &lt; 0)\n  new ArgumentException(\"x must be nonnegative\");\n\n", "role_origin_id": "rule_RSPEC-1848", "role_id": "S1848", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif (x &lt; 0)\n  throw new ArgumentException(\"x must be nonnegative\");\n\n", "role_level": "MAJOR", "role_title_en": "Objects should not be created to be dropped immediately without being used"},{"role_title": "不应在二进制运算符的两面使用相同的表达式.", "role_desc_en": "Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste error and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical operators, having the same value on both sides of an operator yields predictable results, and should be simplified.\nThis rule ignores *, +, =, &lt;&lt;,  and &gt;&gt;.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif ( a == a ) // always true\n{ \n  doZ();\n}\nif ( a != a ) // always false\n{\n  doY();\n}\nif ( a == b &amp;&amp; a == b ) // if the first one is true, the second one is too\n{ \n  doX();\n}\nif ( a == b || a == b ) // if the first one is true, the second one is too\n{ \n  doW();\n}\n\nint j = 5 / 5; //always 1\nint k = 5 - 5; // always 0\n\nc.Equals(c);    //always true\nObject.Equals(c, c); //always true\n\n", "role_origin_id": "rule_RSPEC-1764", "role_id": "S1764", "role_desc": "在二进制运算符的任一侧使用相同的值几乎总是一个错误.在逻辑运算符的情况下，它是一个复制/粘贴错误，因此是一个错误，或者它只是浪费代码，应该被简化.在按位运算符和大多数二进制数学运算符的情况下，在运算符的两侧具有相同的值产生可预测的结果，并且应该被简化.该规则忽略*，+，=，＆lt;＆lt;和＆gt;＆gt;.", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Identical expressions should not be used on both sides of a binary operator"},{"role_title": "跳转语句不能无条件地使用.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nfor (var i = 0; i &lt; 10; i++)\n{\n    Console.WriteLine(i);\n    break;  // loop only executes once\n}\n\nfor (var i = 0; i &lt; 10; i++)\n{\n    continue;\n    Console.WriteLine(i); // this is never executed\n}\n\nfor (var i = 0; i &lt; 10; i++)\n{\n    Console.WriteLine(i);\n    continue;  // this is meaningless; the loop would continue anyway\n}\n\n", "role_origin_id": "rule_RSPEC-1751", "role_id": "S1751", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nfor (var i = 0; i &lt; 10; i++)\n{\n    Console.WriteLine(i);\n}\n\nfor (var i = 0; i &lt; 10; i++)\n{\n    Console.WriteLine(i);\n    if (ErrorOccurred())\n    {\n        break;\n    }\n}\n\n", "role_level": "MAJOR", "role_title_en": "Jump statements should not be used unconditionally"},{"role_title": "变量不应该是自我分配的.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic void SetName(string name)\n{\n  name = name;\n}\n\n", "role_origin_id": "rule_RSPEC-1656", "role_id": "S1656", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic void SetName(string name)\n{\n  this.name = name;\n}\n\n", "role_level": "MAJOR", "role_title_en": "Variables should not be self-assigned"},{"role_title": "“switch”语句不应该有太多的“case”子句.", "role_desc_en": "", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-1479", "role_id": "S1479", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "\"switch\" statements should not have too many \"case\" clauses"},{"role_title": "跟踪“FIXME”标签的使用.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nprivate int Divide(int numerator, int denominator) \n{\n  return numerator / denominator;              // FIXME denominator value might be  0\n}\n\n", "role_origin_id": "rule_RSPEC-1134", "role_id": "S1134", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Track uses of \"FIXME\" tags"},{"role_title": "不应在子表达式中作出分配.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (string.IsNullOrEmpty(result = str.Substring(index, length))) // Noncompliant\n{\n  //...\n}\n\n", "role_origin_id": "rule_RSPEC-1121", "role_id": "S1121", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvar result = str.Substring(index, length);\nif (string.IsNullOrEmpty(result))\n{\n  //...\n}\n\n", "role_level": "MAJOR", "role_title_en": "Assignments should not be made from within sub-expressions"},{"role_title": "实用类不应该有公共构造函数.", "role_desc_en": "Utility classes, which are collections of static members, are not meant to be instantiated. Even abstract utility classes, which can be extended, should not have public constructors.C# adds an implicit public constructor to every class which does not explicitly define at least one constructor. Hence, at least one protected constructor should be defined if you wish to subclass this utility class. Or the static keyword should be added to the class declaration to prevent subclassing.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class StringUtils // Noncompliant\n{ \n  public static string Concatenate(string s1, string s2) \n  {\n    return s1 + s2;\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-1118", "role_id": "S1118", "role_desc": "实用程序类（它们是静态成员的集合）不是要实例化的.即使是可以扩展的抽象实用程序类也不应该有公共构造函数.C＃向每个不显式定义至少一个构造函数的类添加一个隐式的公共构造函数.因此，如果您希望对此实用程序类进行子类化，则应至少定义一个受保护的构造函数.或者static关键字应该添加到类声明中以防止子类化.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic static class StringUtils\n{ \n  public static string Concatenate(string s1, string s2) \n  {\n    return s1 + s2;\n  }\n}\n\n", "role_level": "MAJOR", "role_title_en": "Utility classes should not have public constructors"},{"role_title": "局部变量不应该影响类字段.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass Foo \n{\n  public int myField;\n\n  public void DoSomething() \n  {\n    int myField = 0;  // Noncompliant\n    ...\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-1117", "role_id": "S1117", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Local variables should not shadow class fields"},{"role_title": "可合并的“if”语句应该合并.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (condition1)\n{\n  if (condition2)\n  {        \n    ...\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-1066", "role_id": "S1066", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif (condition1 &amp;&amp; condition2)\n{        \n  ...\n}\n\n", "role_level": "MAJOR", "role_title_en": "Collapsible \"if\" statements should be merged"},{"role_title": "类的继承树不应该太深.", "role_desc_en": "Inheritance is certainly one of the most valuable concepts in object-oriented programming. It's a way to compartmentalize and reuse code by creating collections of attributes and behaviors called classes which can be based on previously created classes. But abusing this concept by creating a deep inheritance tree can lead to very complex and unmaintainable source code. Most of the time a too deep inheritance tree is due to bad object oriented design which has led to systematically use 'inheritance' when for instance 'composition' would suit better.This rule raises an issue when the inheritance tree, starting from Object has a greater depth than is allowed. ", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-110", "role_id": "S110", "role_desc": "继承是面向对象编程中最有价值的概念之一.这是通过创建属性和行为的集合来划分和重用代码的方式，这些属性和行为称为类，可以基于以前创建的类.但是通过创建一个很深的继承树来滥用这个概念可以导致非常复杂和不可维护的源代码.大多数时候，一个太深的继承树是由于面向对象设计不好，导致系统地使用“继承”，当“组合”适合更好.当从Object开始的继承树具有比允许的更深的深度时，此规则引发了一个问题.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Inheritance tree of classes should not be too deep"},{"role_title": "“ToString（）”方法不应该返回null.", "role_desc_en": "Calling ToString() on an object should always return a string. Returning null instead contravenes the method's implicit contract.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic override string ToString ()\n{\n  if (this.collection.Count == 0) \n  {\n    return null; // Noncompliant\n  } \n  else \n  {\n    // ...\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2225", "role_id": "S2225", "role_desc": "调用对象上的ToString（）应该总是返回一个字符串.返回null而不是方法的隐式契约.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic override string ToString () \n{\n  if (this.collection.Count == 0) \n  {\n    return string.Empty;\n  } \n  else \n  {\n    // ...\n  }\n}\n\n", "role_level": "MAJOR", "role_title_en": "\"ToString()\" method should not return null"},{"role_title": "应删除未使用的方法参数.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvoid DoSomething(int a, int b) // \"b\" is unused\n{     \n  Compute(a);\n}\n\nvoid DoSomething2(int a) // value of \"a\" is unused\n{     \n  a = 10;\n  Compute(a);\n}\n\n", "role_origin_id": "rule_RSPEC-1172", "role_id": "S1172", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvoid DoSomething(int a)\n{     \n  Compute(a);\n}\n\nvoid DoSomething2()\n{     \n  var a = 10;\n  Compute(a);\n}\n\n", "role_level": "MAJOR", "role_title_en": "Unused method parameters should be removed"},{"role_title": "类和方法不应该有太多的通用参数.", "role_desc_en": "A method or class with too many type parameters has likely aggregated too many responsibilities and should be split.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\n&lt;S, T, U, V&gt; void foo() {} // Noncompliant; not really readable\n&lt;String, Integer, Object, String&gt;foo(); // especially on invocations\n\n", "role_origin_id": "rule_RSPEC-2436", "role_id": "S2436", "role_desc": "具有太多类型参数的方法或类可能会累积太多的责任，并且应该被分割.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Classes and methods should not have too many generic parameters"},{"role_title": "复合格式字符串应该正确使用.", "role_desc_en": "Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected behaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of String.Format, StringBuilder.AppendFormat, Console.Write, Console.WriteLine, TextWriter.Write, TextWriter.WriteLine, Debug.WriteLine(String, Object[]), Trace.TraceError(String, Object[]), Trace.TraceInformation(String, Object[]), Trace.TraceWarning(String, Object[]) and TraceSource.TraceInformation(String, Object[]). ", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\ns = string.Format(\"{0}\", arg0, arg1); // Noncompliant, arg1 is declared but not used.\ns = string.Format(\"{0} {2}\", arg0, arg1, arg2); // Noncompliant, the format item with index 1 is missing so arg1 will not be used.\ns = string.Format(\"foo\"); // Noncompliant, there is no need to use string.Format here.\n\n", "role_origin_id": "rule_RSPEC-3457", "role_id": "S3457", "role_desc": "因为复合格式字符串在运行时解释，而不是由编译器验证，它们可能包含导致意外行为或运行时错误的错误.当调用String的方法时，此规则静态地验证复合格式的良好行为.格式，StringBuilder.AppendFormat，控制台.写，控制台.WriteLine，TextWriter.写，TextWriter.WriteLine，Debug.WriteLine（String，Object []），Trace.TraceError（String，Object []），Trace.TraceInformation（String，Object []），Trace.TraceWarning（String，Object []）和TraceSource.TraceInformation（字符串，对象[]）.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\ns = string.Format(\"{0}\", arg0);\ns = string.Format(\"{0} {1}\", arg0, arg2);\ns = \"foo\";\n\n", "role_level": "MAJOR", "role_title_en": "Composite format strings should be used correctly"},{"role_title": "一般异常不应该被抛出.", "role_desc_en": "Throwing such general exceptions as Exception, SystemException, ApplicationException, IndexOutOfRangeException, NullReferenceException, OutOfMemoryException and ExecutionEngineException prevents calling methods from handling true, system-generated exceptions differently than application-generated errors. ", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic void DoSomething(object obj)\n{\n  if (obj == null)\n  {\n    throw new NullReferenceException(\"obj\");  // Noncompliant\n  }\n  // ...\n}\n\n", "role_origin_id": "rule_RSPEC-112", "role_id": "S112", "role_desc": "抛出诸如Exception，SystemException，ApplicationException，IndexOutOfRangeException，NullReferenceException，OutOfMemoryException和ExecutionEngineException之类的一般异常会阻止调用方法处理真正的系统生成的异常，而不是应用程序生成的错误.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic void DoSomething(object obj)\n{\n  if (obj == null)\n  {\n    throw new ArgumentNullException(\"obj\");\n  }\n  // ...\n}\n\n", "role_level": "MAJOR", "role_title_en": "General exceptions should never be thrown"},{"role_title": "方法不应该有太多的参数.", "role_desc_en": "A long parameter list can indicate that a new structure should be created to wrap the numerous parameters or that the function is doing too many things.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic void doSomething(int param1, int param2, int param3, string param4, long param5) \n{\n...\n}\n\n", "role_origin_id": "rule_RSPEC-107", "role_id": "S107", "role_desc": "长参数列表可以指示应该创建一个新的结构来包装大量参数，或者该函数做太多的事情.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic void doSomething(int param1, int param2, int param3, string param4) \n{\n...\n}\n\n", "role_level": "MAJOR", "role_title_en": "Methods should not have too many parameters"},{"role_title": "应删除未使用的私有类型或成员.", "role_desc_en": "private or internal types or private members that are never executed or referenced are dead code: unnecessary, inoperative code that should be removed. Cleaning out dead code decreases the size of the maintained codebase, making it easier to understand the program and preventing bugs from being introduced.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Foo\n{\n  private void UnusedPrivateMethod() {...} // Noncompliant\n\n  private class UnusedClass {...} // Noncompliant\n}\n\n", "role_origin_id": "rule_RSPEC-1144", "role_id": "S1144", "role_desc": "从未执行或引用的私有或内部类型或私有成员都是死码：不必要的，应该删除的不工作代码.清理死码会减少维护的代码库的大小，从而更容易理解程序并防止引入错误.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Foo\n{\n  private Foo()\n  {\n    UsedPrivateMethod();\n  }\n\n  private void UsedPrivateMethod() \n  {\n    var c = new UsedClass();\n  } \n\n  private class UsedClass {...}\n}\n\n", "role_level": "MAJOR", "role_title_en": "Unused private types or members should be removed"},{"role_title": "直接扩展“对象”的类不应该在“GetHashCode”或“Equals”中调用“base”.", "role_desc_en": "Making a base call in an overriding method is generally a good idea, but not in GetHashCode and Equals for classes that directly extend object because those methods are based on the object reference. Meaning that no two objects that use those base methods will ever be equal or have the same hash.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Point\n{\n  private readonly int x;\n  public MyClass(int x)\n  {\n    ", "role_origin_id": "rule_RSPEC-3249", "role_id": "S3249", "role_desc": "以覆盖方法进行基本调用通常是一个好主意，但不能在GetHashCode和Equals中直接扩展对象的类，因为这些方法基于对象引用.意思是没有使用这些基本方法的两个对象将相同或具有相同的哈希.", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Classes directly extending \"object\" should not call \"base\" in \"GetHashCode\" or \"Equals\""},