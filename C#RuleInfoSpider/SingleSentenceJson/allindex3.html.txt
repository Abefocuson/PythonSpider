{"role_title": "类不应该只有“私有”构造函数.", "role_desc_en": "A class with only private constructors can't be instantiated, thus, it seems to be pointless code.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class MyClass // Noncompliant\n{\n  private MyClass() { ... }\n}\n\n", "role_origin_id": "rule_RSPEC-3453", "role_id": "S3453", "role_desc": "只有私有构造函数的类不能被实例化，因此似乎是无意义的代码.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class MyClass \n{\n  public MyClass() { ... }\n}\n\n", "role_level": "MAJOR", "role_title_en": "Classes should not have only \"private\" constructors"},{"role_title": "提供“Equals（\\u003cT\\u003e）”或覆盖“Equals（Object）”的类应实现“IEquatable \\u003cT\\u003e”.", "role_desc_en": "The IEquatable&lt;T&gt; interface has only one method in it: Equals(&lt;T&gt;). If you've already written Equals(T), there's no reason not to explicitly implement IEquatable&lt;T&gt;. Doing so expands the utility of your class by allowing it to be used where an IEquatable is called for.Similarly, having written Equals(&lt;T&gt;), it's not that much further to go to write Equals(Object) and vice versa; just a couple more lines brings a large dividend of functionality. So this rule raises an issue when Equals(&lt;T&gt;) is not accompanied by IEquatable and Equals(Object), and vice versa.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass MyClass  // Noncompliant\n{\n  public override bool Equals(object other)\n  {\n    //...\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3897", "role_id": "S3897", "role_desc": "IEquatable＆lt; T＆gt;.如果你已经写了Equals（T），那么没有理由不明确地实现IEquatable＆T;.这样做可以扩展您的类的实用程序，方法是将其用于调用IEquatable的位置.类似地，在写入Equals（＆lt; T））时，写入Equals（Object）并没有太多进一步的，反之亦然;.所以当Equals（＆lt; T＆gt;）不伴随着IEquatable和Equals（Object）时，这个规则引发了一个问题，反之亦然.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass MyClass : IEquatable&lt;MyClass&gt;\n{\n  public override bool Equals(object other)\n  {\n    return Equals(other as MyClass);\n  }\n\n  public bool Equals(MyClass other) \n  {\n    //...\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Classes that provide \"Equals(<T>)\" or override \"Equals(Object)\" should implement \"IEquatable<T>\""},{"role_title": "代表不应该被减去.", "role_desc_en": "In C#, delegates can be added together to chain their execution, and subtracted to remove their execution from the chain.Subtracting a chain of delegates from another one might yield unexpected results as shown hereunder - and is likely to be a bug.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nMyDelegate first, second, third, fourth;\nfirst = () =&gt; Console.Write(\"1\");\nsecond = () =&gt; Console.Write(\"2\");\nthird = () =&gt; Console.Write(\"3\");\nfourth = () =&gt; Console.Write(\"4\");\n\nMyDelegate chain1234 = first + second + third + fourth; // Compliant - chain sequence = \"1234\"\nMyDelegate chain12 = chain1234 - third - fourth; // Compliant - chain sequence = \"12\"\n\n\nMyDelegate chain14 = first + fourth; // creates a new MyDelegate instance which is a list under the covers\nMyDelegate chain23 = chain1234 - chain14; // Noncompliant; (first + fourth) doesn't exist in chain1234\n\n\n// The chain sequence of \"chain23\" will be \"1234\" instead of \"23\"!\n// Indeed, the sequence \"1234\" does not contain the subsequence \"14\", so nothing is subtracted\n// (but note that \"1234\" contains both the \"1\" and \"4\" subsequences)\nchain23 = chain1234 - (first + fourth); // Noncompliant\n\nchain23(); // will print \"1234\"!\n\n", "role_origin_id": "rule_RSPEC-3172", "role_id": "S3172", "role_desc": "在C＃中，代理可以加在一起以链接其执行，并减去它们从链中删除其执行.从另一个减去代表链可能会产生意想不到的结果，如下所示 - 可能是一个错误.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nMyDelegate chain23 = chain1234 - first - fourth; // Compliant - \"1\" is first removed, followed by \"4\"\n\nchain23(); // will print \"23\"\n\n", "role_level": "MAJOR", "role_title_en": "Delegates should not be subtracted"},{"role_title": "应为“可选字段”成员提供反序列化方法.", "role_desc_en": "Fields marked with System.Runtime.Serialization.OptionalFieldAttribute are serialized just like any other field. But such fields are ignored on deserialization, and retain the default values associated with their types. Therefore, deserialization event handlers should be declared to set such fields during the deserialization process.This rule raises when at least one field with the System.Runtime.Serialization.OptionalFieldAttribute attribute is declared but one (or both) of the following event handlers System.Runtime.Serialization.OnDeserializingAttribute or System.Runtime.Serialization.OnDeserializedAttribute are not present.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\n[Serializable]\npublic class Foo\n{\n    [OptionalField(VersionAdded = 2)]\n    int optionalField = 5;    \n}\n\n", "role_origin_id": "rule_RSPEC-3926", "role_id": "S3926", "role_desc": "标有系统的字段.运行.序列化.OptionalFieldAttribute就像任何其他字段一样被序列化.但这样的字段在反序列化时被忽略，并保留与其类型相关联的默认值.因此，反序列化事件处理程序应该被声明在反序列化过程中设置这样的字段.当系统至少有一个字段时，此规则会引发.运行.序列化.OptionalFieldAttribute属性被声明为一个（或两个）以下事件处理程序System.运行.序列化.OnDeserializingAttribute或System.运行.序列化.OnDeserializedAttribute不存在.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\n[Serializable]\npublic class Foo\n{\n    [OptionalField(VersionAdded = 2)]\n    int optionalField = 5;\n    \n    [OnDeserializing]\n    void OnDeserializing(StreamingContext context)\n    {\n\t    optionalField = 5;\n    }\n    \n    [OnDeserialized]\n    void OnDeserialized(StreamingContext context)\n    {\n        // Set optionalField if dependent on other deserialized values.\n    }\n}\n\n", "role_level": "MAJOR", "role_title_en": "Deserialization methods should be provided for \"OptionalField\" members"},{"role_title": "双重前缀运算符“!!”.", "role_desc_en": "Calling the ! or ~ prefix operator twice does nothing: the second invocation undoes the first. Such mistakes are typically caused by accidentally double-tapping the key in question without noticing.Either this is a bug, if the operator was actually meant to be called once, or misleading if done on purpose.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nint v1 = 0;\nbool v2 = false;\n\nvar v3 = !!v1; // Noncompliant\nvar v4 = ~~v2; // Noncompliant\n\n", "role_origin_id": "rule_RSPEC-2761", "role_id": "S2761", "role_desc": "打电话给！.这种错误通常是由于意外地双击所关注的密钥而没有注意到.这是一个错误，如果操作者实际上是打算被叫一次，或者是误导，如果有目的的话.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nint v1 = 0;\nbool v2 = false;\n\nvar v3 = !v1;\nvar v4 = ~v2;\n\n", "role_level": "MAJOR", "role_title_en": "Doubled prefix operators \"!!\" and \"~~\" should not be used"},{"role_title": "空的可空值不应被访问.", "role_desc_en": "Nullable value types can hold either a value or null. The value held in the nullable type can be accessed with the Value property, but .Value throws an InvalidOperationException when the value is null. To avoid the exception, a nullable type should always be tested before .Value is accessed.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nint? nullable = null;\n...\nUseValue(nullable.Value); // Noncompliant\n\n", "role_origin_id": "rule_RSPEC-3655", "role_id": "S3655", "role_desc": "可空值可以包含一个值或一个null.可以使用Value属性访问保持在可空类型中的值，但是.当值为null时，值会抛出InvalidOperationException异常.为了避免这个例外，一个可以为空的类型应该先经过测试.访问值.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nint? nullable = null;\n...\nif (nullable.HasValue)\n{\n  UseValue(nullable.Value);\n}\n\n", "role_level": "MAJOR", "role_title_en": "Empty nullable value should not be accessed"},{"role_title": "事件应该被调用.", "role_desc_en": "Events that are not invoked anywhere are dead code, and there's no good reason to keep them in the source.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass UninvokedEventSample\n{\n    private event Action&lt;object, EventArgs&gt; Happened; //Noncompliant\n\n    public void RegisterEventHandler(Action&lt;object, EventArgs&gt; handler)\n    {\n        Happened += handler; //we register some event handlers\n    }\n\n    public void RaiseEvent()\n    {\n        if (Happened != null)\n        {\n            // Happened(this, null); // the event is never triggered, because this line is commented out.\n        }\n    }\n}\n\n", "role_origin_id": "rule_RSPEC-3264", "role_id": "S3264", "role_desc": "在任何地方没有被调用的事件都是死码，没有什么好的理由将它们保留在源代码中.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Events should be invoked"},{"role_title": "异常不应该被明确地推翻.", "role_desc_en": "When rethrowing an exception, you should do it by simply calling throw; and not throw exc;, because the stack trace is reset with the second syntax, making debugging a lot harder.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\ntry\n{}\ncatch(ExceptionType1 exc)\n{\n  Console.WriteLine(exc);\n  throw exc; // Noncompliant; stacktrace is reset\n}\ncatch (ExceptionType2 exc) \n{\n  throw new Exception(\"My custom message\", exc);  // Compliant; stack trace preserved\n}\n\n", "role_origin_id": "rule_RSPEC-3445", "role_id": "S3445", "role_desc": "当重新抛出异常时，你应该通过简单地调用throw来实现;.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\ntry\n{}\ncatch(ExceptionType1 exc)\n{\n  Console.WriteLine(exc);\n  throw;\n}\ncatch (ExceptionType2 exc) \n{\n  throw new Exception(\"My custom message\", exc);\n}\n\n", "role_level": "MAJOR", "role_title_en": "Exceptions should not be explicitly rethrown"},{"role_title": "仅在构造函数中分配的字段应为“只读”.", "role_desc_en": "readonly fields can only be assigned in a class constructor. If a class has a field that's not marked readonly but is only set in the constructor, it could cause confusion about the field's intended use. To avoid confusion, such fields should be marked readonly to make their intended use explicit, and to prevent future maintainers from inadvertently changing their use.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-2933", "role_id": "S2933", "role_desc": "只读字段只能在类构造函数中分配.如果一个类没有标记为只读的字段，但只能在构造函数中设置，那么可能会导致对字段的预期用途的混淆.为了避免混淆，这些字段应该被标记为只读，以使其用途明确，并防止未来的维护者无意中更改使用.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass Person\n{\n  readonly int _birthYear;\n  Person(int birthYear) \n  {\n    _birthYear = birthYear;\n  }\n}\n\n", "role_level": "MAJOR", "role_title_en": "Fields that are only assigned in the constructor should be \"readonly\""},{"role_title": "通用型参数应尽可能共同/相反.", "role_desc_en": "In the interests of making code as usable as possible, interfaces and delegates with generic parameters should use the out and in modifiers when possible to make the interfaces and delegates covariant and contravariant, respectively.The out keyword can be used when the type parameter is used only as a return type in the interface or delegate. Doing so makes the parameter covariant, and allows interface and delegate instances created with a sub-type to be used as instances created with a base type. The most notable example of this is IEnumerable&lt;out T&gt;, which allows the assignment of an IEnumerable&lt;string&gt; instance to an IEnumerable&lt;object&gt; variable, for instance.The in keyword can be used when the type parameter is used only as a method parameter in the interface or a parameter in the delegate. Doing so makes the parameter contravariant, and allows interface and delegate instances created with a base type to be used as instances created with a sub-type. I.e. this is the inversion of covariance. The most notable example of this is the Action&lt;in T&gt; delegate, which allows the assignment of an Action&lt;object&gt; instance to a Action&lt;string&gt; variable, for instance.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\ninterface IConsumer&lt;T&gt;  // Noncompliant\n{\n    bool Eat(T fruit);\n}\n\n", "role_origin_id": "rule_RSPEC-3246", "role_id": "S3246", "role_desc": "为了尽可能使代码尽可能地使用，具有通用参数的接口和委托应该在可能时使用out和in修饰符分别使接口和委托协变量和反变换.当类型参数仅在接口或委托中作为返回类型使用时，可以使用out关键字.这样做使参数协变，并允许使用子类创建的接口和委托实例作为使用基本类型创建的实例.其中最显着的例子是IEnumerable＆lt; out T＆gt;，其允许分配IEnumerable＆lt; string＆gt;.当type参数仅用作接口中的方法参数或委托中的参数时，可以使用in关键字.这样做会使参数相反，并允许使用基本类型创建的接口和委托实例作为使用子类型创建的实例.一世.这是协方差的反演.其中最显着的例子是Action＆lt; in T＆gt;.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\ninterface IConsumer&lt;in T&gt;\n{\n    bool Eat(T fruit);\n}\n\n", "role_level": "MAJOR", "role_title_en": "Generic type parameters should be co/contravariant when possible"},{"role_title": "“Pure”属性的方法应该返回一个值.", "role_desc_en": "Marking a method with the [Pure] attribute specifies that the method doesn't make any visible changes; thus, the method should return a result, otherwise the call to the method should be equal to no-operation. So [Pure] on a void method is either a mistake, or the method doesn't do any meaningful task.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass Person\n{\n  private int age;\n  [Pure] // Noncompliant. In this case the method makes a possibly visible state change\n  void ConfigureAge(int age)\n  {\n    ...\n    this.age = age;\n  }\n  ...\n}\n\n", "role_origin_id": "rule_RSPEC-3603", "role_id": "S3603", "role_desc": "使用[Pure]属性标记方法指定该方法不会进行任何可见的更改;.所以[Pure]在一个void方法上是一个错误，或者该方法没有任何有意义的任务.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass Person\n{\n  private int age;\n\n  void ConfigureAge(int age)\n  {\n    ...\n    this.age = age;\n  }\n  ...\n}\n\n", "role_level": "MAJOR", "role_title_en": "Methods with \"Pure\" attribute should return a value"},{"role_title": "不应该使用多个“OrderBy”调用.", "role_desc_en": "There's no point in chaining multiple OrderBy calls in a LINQ; only the last one will be reflected in the result because each subsequent call  completely reorders the list. Thus, calling OrderBy multiple times is a performance issue as well, because all of the sorting will be executed, but only the result of the last sort will be kept.Instead, use ThenBy for each call after the first. ", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvar x = personList\n  .OrderBy(person =&gt; person.Age)\n  .OrderBy(person =&gt; person.Name)  // Noncompliant\n  .ToList();  // x is sorted by Name, not sub-sorted\n\n", "role_origin_id": "rule_RSPEC-3169", "role_id": "S3169", "role_desc": "在LINQ中连接多个OrderBy调用没有任何意义;.因此，多次调用OrderBy也是一个性能问题，因为所有的排序都将被执行，但只会保留最后一个排序的结果.相反，在第一个之后的每个调用中使用ThenBy.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvar x = personList\n  .OrderBy(person =&gt; person.Age)\n  .ThenBy(person =&gt; person.Name)\n  .ToList();\n\n", "role_level": "MAJOR", "role_title_en": "Multiple \"OrderBy\" calls should not be used"},{"role_title": "嵌套的代码块不应该是空的.", "role_desc_en": "Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nfor (int i = 0; i &lt; 42; i++){}  // Empty on purpose or missing piece of code ?\n\n", "role_origin_id": "rule_RSPEC-108", "role_id": "S108", "role_desc": "当一段代码真的丢失时，大多数时候代码块是空的.所以这样的空块必须被填充或删除.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Nested blocks of code should not be left empty"},{"role_title": "可空类型比较不应该是多余的.", "role_desc_en": "Calling GetType() on a nullable object returns the underlying value type. Thus, comparing the returned Type object to typeof(Nullable&lt;SomeType&gt;) doesn't make sense. The comparison either throws an exception or the result can be known at compile time.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nint? nullable = 42;\nbool comparison = nullable.GetType() == typeof(Nullable&lt;int&gt;); // Noncompliant, always false\ncomparison = nullable.GetType() != typeof(Nullable&lt;int&gt;); // Noncompliant, always true\n\nnullable = null;\ncomparison = nullable.GetType() != typeof(Nullable&lt;int&gt;); // Noncompliant, calling GetType on a null always throws an exception\n\n", "role_origin_id": "rule_RSPEC-3610", "role_id": "S3610", "role_desc": "在可空对象上调用GetType（）返回底层值类型.因此，将返回的Type对象与typeof（Nullable＆lt; SomeType＆gt;）进行比较没有任何意义.比较引发异常或结果可以在编译时知道.", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Nullable type comparison should not be redundant"},{"role_title": "单向“OperationContract”方法应该具有“void”返回类型.", "role_desc_en": "When declaring a Windows Communication Foundation (WCF) OperationContract method one-way, that service method won't return any result, not even an underlying empty confirmation message. These are fire-and-forget methods that are useful in event-like communication. Specifying a return type therefore does not make sense.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\n[ServiceContract]\ninterface IMyService \n{\n  [OperationContract(IsOneWay = true)]\n  int SomethingHappened(int parameter); // Noncompliant\n}\n\n", "role_origin_id": "rule_RSPEC-3598", "role_id": "S3598", "role_desc": "当以单向方式声明Windows Communication Foundation（WCF）OperationContract方法时，该服务方法将不会返回任何结果，甚至没有底层的空确认消息.这些是在类似事件的通信中有用的消防方式.因此，指定返回类型是没有意义的.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\n[ServiceContract]\ninterface IMyService \n{\n  [OperationContract(IsOneWay = true)]\n  void SomethingHappened(int parameter);\n}\n\n", "role_level": "MAJOR", "role_title_en": "One-way \"OperationContract\" methods should have \"void\" return type"},{"role_title": "可选参数应传递给“基”调用.", "role_desc_en": "Generally, writing the least code that will readably do the job is a good thing, so omitting default parameter values seems to make sense. Unfortunately, when you omit them from the base call in an override, you're not actually getting the job done thoroughly, because you're ignoring the value the caller passed in. The result will likely not be what the caller expected.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class BaseClass\n{\n    public virtual void MyMethod(int i = 1)\n    { \n        Console.WriteLine(i);\n    }\n}\n\npublic class DerivedClass : BaseClass\n{\n    public override void MyMethod(int i = 1)\n    {\n        // ... \n        base.MyMethod(); // Noncompliant; caller's value is ignored\n    }\n\n    static int Main(string[] args) \n    {\n        DerivedClass dc = new DerivedClass();\n        dc.MyMethod(12);  // prints 1\n    }\n}\n\n", "role_origin_id": "rule_RSPEC-3466", "role_id": "S3466", "role_desc": "一般来说，编写可以轻松完成工作的最小代码是一件好事，因此省略默认参数值似乎是有道理的.不幸的是，当您在覆盖中从基础调用中省略它们时，实际上并没有彻底地完成工作，因为您忽略了调用者传递的值.结果可能不是呼叫者预期的.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class BaseClass\n{\n    public virtual void MyMethod(int i = 1)\n    { \n        Console.WriteLine(i);\n    }\n}\n\npublic class DerivedClass : BaseClass\n{\n    public override void MyMethod(int i = 1)\n    {\n        // ... \n        base.MyMethod(i);\n    }\n\n    static int Main(string[] args) \n    {\n        DerivedClass dc = new DerivedClass();\n        dc.MyMethod(12);  // prints 12\n    }\n}\n\n", "role_level": "MAJOR", "role_title_en": "Optional parameters should be passed to \"base\" calls"},{"role_title": "用于ArgumentException构造函数的参数名称应与现有构造函数匹配.", "role_desc_en": "Some constructors of the ArgumentException, ArgumentNullException, ArgumentOutOfRangeException and DuplicateWaitObjectException classes must be fed with a valid parameter name. This rule raises an issue in two cases:", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic void Foo(Bar a, int[] b) \n{\n  throw new ArgumentException(); // Noncompliant\n  throw new ArgumentException(\"My error message\", \"c\"); // Noncompliant\n  throw new ArgumentException(\"My error message\", \"c\", innerException); // Noncompliant \n  throw new ArgumentNullException(\"c\"); // Noncompliant\n  throw new ArgumentNullException(\"My error message\", \"c\"); // Noncompliant\n  throw new ArgumentOutOfRangeException(\"c\");\n  throw new ArgumentOutOfRangeException(\"c\", \"My error message\"); // Noncompliant\n  throw new ArgumentOutOfRangeException(\"c\", b, \"My error message\"); // Noncompliant\n}\n\n", "role_origin_id": "rule_RSPEC-3928", "role_id": "S3928", "role_desc": "ArgumentException，ArgumentNullException，ArgumentOutOfRangeException和DuplicateWaitObjectException类的某些构造函数必须使用有效的参数名称.这个规则在两种情况下提出了一个问题：.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Parameter names used into ArgumentException constructors should match an existing one"},{"role_title": "代码段不应该被“注释掉”.", "role_desc_en": "Programmers should not comment out code as it bloats programs and reduces readability.\nUnused code should be deleted and can be retrieved from source control history if required.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-125", "role_id": "S125", "role_desc": "程序员不应该将代码注释掉，因为它会膨胀程序并降低可读性.应该删除未使用的代码，如果需要，可以从源代码控制历史记录中检索.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Sections of code should not be \"commented out\""},{"role_title": "静态字段应按照必须初始化的顺序显示.", "role_desc_en": "Static field initializers are executed in the order in which they appear in the class from top to bottom. Thus, placing a static field in a class above the field or fields required for its initialization will yield unexpected results.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass MyClass\n{\n  public static int X = Y; // Noncompliant; Y at this time is still assigned default(int), i.e. 0\n  public static int Y = 42;\n}\n\n", "role_origin_id": "rule_RSPEC-3263", "role_id": "S3263", "role_desc": "静态字段初始化器按照从上到下在类中出现的顺序执行.因此，将一个静态字段放在上面所需的字段或类似的字段中会产生意想不到的结果.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass MyClass\n{\n  public static int Y = 42;\n  public static int X = Y;\n}\n\n", "role_level": "MAJOR", "role_title_en": "Static fields should appear in the order they must be initialized"},{"role_title": "静态字段不应该在通用类型中使用.", "role_desc_en": "A static field in a generic type is not shared among instances of different closed constructed types, thus LengthLimitedSingletonCollection&lt;int&gt;.instances and LengthLimitedSingletonCollection&lt;string&gt;.instances will point to different objects, even though instances is seemingly shared among all LengthLimitedSingletonCollection&lt;&gt; generic classes.If you need to have a static field shared among instances with different generic arguments, define a non-generic base class to store your static members, then set your generic type to inherit from the base class.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class LengthLimitedSingletonCollection&lt;T&gt; where T : new() \n{\n  protected const int MaxAllowedLength = 5;\n  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;(); // Noncompliant\n\n  public static T GetInstance() \n  {\n    object instance;\n\n    if (!instances.TryGetValue(typeof(T), out instance)) \n    {\n      if (instances.Count &gt;= MaxAllowedLength) \n      {\n        throw new Exception();\n      }\n      instance = new T();\n      instances.Add(typeof(T), instance);\n    }\n    return (T)instance;\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2743", "role_id": "S2743", "role_desc": "通用类型中的静态字段不在不同封闭构造类型的实例之间共享，因此LengthLimitedSingletonCollection＆lt; int＆gt;.实例和LengthLimitedSingletonCollection＆lt; string＆gt;.实例将指向不同的对象，即使实例在所有长度有限的SingletonCollection＆lt;＆gt;.如果您需要在具有不同通用参数的实例之间共享一个静态字段，请定义一个非泛型基类来存储静态成员，然后将通用类型设置为从基类继承.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class SingletonCollectionBase \n{\n  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;(); \n}\n\npublic class LengthLimitedSingletonCollection&lt;T&gt; : SingletonCollectionBase where T : new()\n{\n  protected const int MaxAllowedLength = 5;\n\n  public static T GetInstance() \n  {\n    object instance;\n\n    if (!instances.TryGetValue(typeof(T), out instance)) \n    {\n      if (instances.Count &gt;= MaxAllowedLength) \n      {\n        throw new Exception();\n      }\n      instance = new T();\n      instances.Add(typeof(T), instance);\n    }\n    return (T)instance;\n  }\n}\n\n", "role_level": "MAJOR", "role_title_en": "Static fields should not be used in generic types"},{"role_title": "类型应在命名空间中定义.", "role_desc_en": "Types are declared in namespaces in order to prevent name collisions and as a way to organize them into the object hierarchy. Types that are defined outside any named namespace are in a global namespace that cannot be referenced in code.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Foo // Noncompliant\n{\n}\n\npublic struct Bar // Noncompliant\n{\n}\n\n", "role_origin_id": "rule_RSPEC-3903", "role_id": "S3903", "role_desc": "类型在命名空间中声明，以防止名称冲突，并将其组织到对象层次结构中.在任何命名空间之外定义的类型都在全局命名空间中，不能在代码中引用.", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Types should be defined in named namespaces"},{"role_title": "应删除未使用的类型参数.", "role_desc_en": "Type parameters that aren't used are dead code, which can only distract and possibly confuse developers during maintenance. Therefore, unused type parameters should be removed.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class MoreMath&lt;T&gt;   // Noncompliant; &lt;T&gt; is ignored\n{\n  public int Add&lt;T&gt;(int a, int b) // Noncompliant; &lt;T&gt; is ignored\n  {\n    return a + b; \n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2326", "role_id": "S2326", "role_desc": "不使用的类型参数是死代码，只能在维护期间分散注意力并可能混淆开发人员.因此，应该删除未使用的类型参数.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class MoreMath \n{\n  public int Add (int a, int b)\n  {\n    return a + b; \n  }\n}\n\n", "role_level": "MAJOR", "role_title_en": "Unused type parameters should be removed"},{"role_title": "“GetHashCode”不应该引用可变字段.", "role_desc_en": "GetHashCode is used to file an object in a Dictionary or Hashtable. If GetHashCode uses non-readonly fields and those fields change after the object is stored, the object immediately becomes mis-filed in the Hashtable. Any subsequent test to see if the object is in the Hashtable will return a false negative.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Person \n{\n  public int age;\n  public string name;\n\n  public override int GetHashCode() \n  {\n    int hash = 12;\n    hash += this.age.GetHashCode(); // Noncompliant\n    hash += this.name.GetHashCode(); // Noncompliant\n    return hash;\n  }\n\n", "role_origin_id": "rule_RSPEC-2328", "role_id": "S2328", "role_desc": "GetHashCode用于在Dictionary或Hashtable中提供对象.如果GetHashCode使用非readonly字段，并且这些字段在对象被存储之后发生更改，则该对象立即在Hashtable中被错误地归档.任何后续测试，以查看该对象是否在Hashtable中将返回一个假负数.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Person \n{\n  public readonly DateTime birthday;\n  public string name;\n\n  public override int GetHashCode() \n  {\n    int hash = 12;\n    hash += this.birthday.GetHashCode();\n    return hash;\n  }\n\n", "role_level": "MINOR", "role_title_en": "\"GetHashCode\" should not reference mutable fields"},{"role_title": "“基础.如果“base”不是“object”，则不应使用“Equals”来检查“Equals”中的引用相等性.", "role_desc_en": "object.Equals() overrides can be optimized by checking first for reference equality between this and the parameter. This check can be implemented by calling object.ReferenceEquals() or base.Equals(), where base is object. However, using base.Equals() is a maintenance hazard because while it works if you extend Object directly, if you introduce a new base class that overrides Equals, it suddenly stops working.This rule raises an issue if base.Equals() is used but base is not object.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass Base\n{\n  private int baseField;\n\n  public override bool Equals(object other)\n  {\n    if (base.Equals(other)) // Okay; base is object\n    {\n      return true;\n    }\n\n    return this.baseField == ((Base)other).baseField;\n  }\n}\n\nclass Derived : Base\n{\n  private int derivedField;\n\n  public override bool Equals(object other)\n  {\n    if (base.Equals(other))  // Noncompliant\n    {\n      return true;\n    }\n\n    return this.derivedField == ((Derived)other).derivedField;\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3397", "role_id": "S3397", "role_desc": "目的.可以通过首先检查此参数之间的参考等同性来优化Equals（）覆盖.此检查可以通过调用对象来实现.ReferenceEquals（）或base.Equals（），其中base是对象.但是，使用base.Equals（）是一个维护危险，因为如果您直接扩展Object，它可以工作，如果引入覆盖Equals的新基类，它将突然停止工作.这个规则引发了一个问题，如果基础.使用Equals（），但base不是对象.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass Base\n{\n  private int baseField;\n\n  public override bool Equals(object other)\n  {\n    if (object.ReferenceEquals(this, other))  // base.Equals is okay here, but object.ReferenceEquals is better\n    {\n      return true;\n    }\n\n    return this.baseField == ((Base)other).baseField;\n  }\n}\n\nclass Derived : Base\n{\n  private int derivedField;\n\n  public override bool Equals(object other)\n  {\n    if (object.ReferenceEquals(this, other))\n    {\n      return true;\n    }\n\n    return base.Equals(other) &amp;&amp; this.derivedField == ((Derived)other).derivedField;\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "\"base.Equals\" should not be used to check for reference equality in \"Equals\" if \"base\" is not \"object\""},{"role_title": "“捕捉”条款应该做的不止是反驳.", "role_desc_en": "A catch clause that only rethrows the caught exception has the same effect as omitting the catch altogether and letting it bubble up automatically, but with more code and the additional detrement of leaving maintainers scratching their heads. Such clauses should either be eliminated or populated with the appropriate logic.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nstring s = \"\";\ntry\n{\n  s = File.ReadAllText(fileName);\n}\ncatch (Exception e)  // Noncompliant\n{ \n  throw;\n}\n\n", "role_origin_id": "rule_RSPEC-2737", "role_id": "S2737", "role_desc": "只有重新启动捕获到的异常的catch子句具有完全省略捕获的功能，并且自动启动它，但是具有更多的代码和额外的损害，让维护者抓住头部.这些条款应该被消除或者填入适当的逻辑.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nstring s = \"\";\ntry \n{\n  s = File.ReadAllText(fileName);\n}\ncatch (Exception e) // Compliant\n{  \n  logger.LogError(e);\n  throw;\n}\n\n", "role_level": "MINOR", "role_title_en": "\"catch\" clauses should do more than rethrow"},{"role_title": "“串.IsNullOrEmpty“.", "role_desc_en": "Using string.Equals to determine if a string is empty is significantly slower than using string.IsNullOrEmpty() or checking for string.Length == 0. string.IsNullOrEmpty() is both clear and concise, and therefore preferred to laborious, error-prone, manual null- and emptiness-checking.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\n\"\".Equals(name); // Noncompliant\n!name.Equals(\"\"); // Noncompliant\nname.Equals(string.Empty); // Noncompliant\n\n", "role_origin_id": "rule_RSPEC-3256", "role_id": "S3256", "role_desc": "使用字符串.相当于确定一个字符串是否为空，显着慢于使用字符串.IsNullOrEmpty（）或检查字符串.长度== 0.串.IsNullOrEmpty（）既清晰简洁，因此更倾向于费力，容易出错的手动空和空白检查.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nname != null &amp;&amp; name.Length &gt; 0 // Compliant but more error prone\n!string.IsNullOrEmpty(name)\nstring.IsNullOrEmpty(name)\n\n", "role_level": "MINOR", "role_title_en": "\"string.IsNullOrEmpty\" should be used"},{"role_title": "“串.ToCharArray（）“不应该被冗余调用.", "role_desc_en": "ToCharArray can be omitted when the operation on the array could have been done directly on the string, such as when iterating over the characters in a string, and when accessing a character in a string via an array index. In those cases, explicit ToCharArray calls should be omitted.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nstring str = \"some string\";\nforeach (var c in str.ToCharArray()) // Noncompliant\n{\n  // ...    \n}\n\n", "role_origin_id": "rule_RSPEC-3456", "role_id": "S3456", "role_desc": "当数组上的操作可以直接在字符串上完成时，例如当迭代字符串中的字符，以及通过数组索引访问字符串中的字符时，ToCharArray可以被省略.在这些情况下，应该省略显式的ToCharArray调用.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nstring str = \"some string\";\nforeach (var c in str)\n{\n  // ...    \n}\n\n", "role_level": "MINOR", "role_title_en": "\"string.ToCharArray()\" should not be called redundantly"},{"role_title": "Attribute，EventArgs和Exception类型名称应以扩展类型结束.", "role_desc_en": "Adherence to the standard naming conventions makes your code not only more readable, but more usable. For instance, class FirstAttribute : Attribute can be used simply with First, but you must use the full name for class AttributeOne : Attribute.This rule raises an issue when classes extending Attribute, EventArgs, or Exception, do not end with their parent class names.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass AttributeOne : Attribute  // Noncompliant\n{\n}\n\n", "role_origin_id": "rule_RSPEC-3376", "role_id": "S3376", "role_desc": "遵守标准命名约定使您的代码不仅更易读，更可用.例如，FirstAttribute：Attribute类可以简单地使用First，但是您必须使用AttributeOne类的全名：Attribute.当扩展Attribute，EventArgs或Exception的类不以其父类名称结尾时，此规则引发问题.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass FirstAttribute : Attribute \n{\n}\n\n", "role_level": "MINOR", "role_title_en": "Attribute, EventArgs, and Exception type names should end with the type being extended"},{"role_title": "应该省略空的“case”子句落入“default”.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nswitch(ch) \n{\n  case 'a' :\n    HandleA();\n    break;\n  case 'b' :\n    HandleB();\n    break;\n  case 'c' :  // Noncompliant\n  default:\n    HandleTheRest();\n    break;\n}\n\n", "role_origin_id": "rule_RSPEC-3458", "role_id": "S3458", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nswitch(ch) \n{\n  case 'a' :\n    HandleA();\n    break;\n  case 'b' :\n    HandleB();\n    break;\n  default:\n    HandleTheRest();\n    break;\n}\n\n", "role_level": "MINOR", "role_title_en": "Empty \"case\" clauses that fall through to the \"default\" should be omitted"},{"role_title": "可变字段不应该是“public static”.", "role_desc_en": "public static mutable fields of classes which are accessed directly should be protected to the degree possible. This can be done by reducing the accessibility of the field or by changing the return type to an immutable type.This rule raises issues for public static fields with a type inheriting/implementing System.Array or System.Collections.Generic.ICollection&lt;T&gt;.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class A \n{\n  public static string[] strings1 = {\"first\",\"second\"};  // Noncompliant\n  public static List&lt;String&gt; strings3 = new List&lt;String&gt;();  // Noncompliant\n  // ...\n}\n\n", "role_origin_id": "rule_RSPEC-2386", "role_id": "S2386", "role_desc": "直接访问的类的公共静态可变字段应尽可能保护.这可以通过减少字段的可访问性或将返回类型更改为不可变类型来完成.该规则引入了具有类型继承/实现系统的公共静态字段的问题.阵列或系统.集合.通用.的ICollection＆LT; T＆GT;.", "role_type": "Vulnerability", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Mutable fields should not be \"public static\""},{"role_title": "标志枚举应明确地初始化其所有成员.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\n[Flags]\nenum FruitType    // Noncompliant\n{\n  None,\n  Banana,\n  Orange,\n  Strawberry\n}\nclass Program\n{\n    static void Main()\n    {\n        var bananaAndStrawberry = FruitType.Banana | FruitType.Strawberry;\n        // Will display only Strawberry!\n        Console.WriteLine(bananaAndStrawberry.ToString());\n    }\n}\n\n", "role_origin_id": "rule_RSPEC-2345", "role_id": "S2345", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\n[Flags]\nenum FruitType\n{\n  None = 0,\n  Banana = 1,\n  Orange = 2,\n  Strawberry = 4\n}\nclass Program\n{\n    static void Main()\n    {\n        var bananaAndStrawberry = FruitType.Banana | FruitType.Strawberry;\n        // Will display Banana and Strawberry, as expected.\n        Console.WriteLine(bananaAndStrawberry.ToString());\n    }\n}\n\n", "role_level": "MINOR", "role_title_en": "Flags enumerations should explicitly initialize all their members"},{"role_title": "枚举类型名称不应该有“Flags”或“Enum”后缀.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nenum FooFlags // Noncompliant\n{\n    Foo = 1\n    Bar = 2\n    Baz = 4\n}\n\n", "role_origin_id": "rule_RSPEC-2344", "role_id": "S2344", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nenum Foo\n{\n    Foo = 1\n    Bar = 2\n    Baz = 4\n}\n\n", "role_level": "MINOR", "role_title_en": "Enumeration type names should not have \"Flags\" or \"Enum\" suffixes"},{"role_title": "枚举类型应符合命名约定.", "role_desc_en": "Shared naming conventions allow teams to collaborate efficiently. This rule checks that all enum names match a provided regular expression.The default configuration is the one recommended by Microsoft:", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic enum foo // Noncompliant\n{\n    FooValue = 0\n}\n\n", "role_origin_id": "rule_RSPEC-2342", "role_id": "S2342", "role_desc": "共享命名约定允许团队有效协作.此规则检查所有枚举名称是否与提供的正则表达式匹配.默认配置是由Microsoft推荐的配置：.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic enum Foo\n{\n    FooValue = 0\n}\n\n", "role_level": "MINOR", "role_title_en": "Enumeration types should comply with a naming convention"},{"role_title": "布尔检查不应该被反转.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif ( !(a == 2)) { ...}  // Noncompliant\nbool b = !(i &lt; 10);  // Noncompliant\n\n", "role_origin_id": "rule_RSPEC-1940", "role_id": "S1940", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif (a != 2) { ...} \nbool b = (i &gt;= 10);\n\n", "role_level": "MINOR", "role_title_en": "Boolean checks should not be inverted"},{"role_title": "不应使用冗余的演员.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic int Example(int i) \n{\n  return (int) (i + 42); // Noncompliant\n}\npublic IEnumerable&lt;int&gt; ExampleCollection(IEnumerable&lt;int&gt; coll) \n{\n  return coll.Reverse().OfType&lt;int&gt;(); // Noncompliant\n}\n\n", "role_origin_id": "rule_RSPEC-1905", "role_id": "S1905", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic int Example(int i) \n{\n  return i + 42;\n}\npublic IEnumerable&lt;int&gt; ExampleCollection(IEnumerable&lt;int&gt; coll) \n{\n  return coll.Reverse();\n}\n\n", "role_level": "MINOR", "role_title_en": "Redundant casts should not be used"},{"role_title": "字符串不应该在循环中使用'+'连接.", "role_desc_en": "StringBuilder is more efficient than string concatenation, especially when the operator is repeated over and over as in loops.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nstring str = \"\";\nfor (int i = 0; i &lt; arrayOfStrings.Length ; ++i) \n{\n  str = str + arrayOfStrings[i];\n}\n\n", "role_origin_id": "rule_RSPEC-1643", "role_id": "S1643", "role_desc": "StringBuilder比字符串连接效率更高，特别是当操作符重复一遍地循环时.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nStringBuilder bld = new StringBuilder();\nfor (int i = 0; i &lt; arrayOfStrings.Length; ++i) \n{\n  bld.Append(arrayOfStrings[i]);\n}\nstring str = bld.ToString();\n\n", "role_level": "MINOR", "role_title_en": "Strings should not be concatenated using '+' in a loop"},{"role_title": "应删除未使用的局部变量.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic int NumberOfMinutes(int hours)\n{\n  int seconds = 0;   // seconds is never used \n  return hours * 60;\n}\n\n", "role_origin_id": "rule_RSPEC-1481", "role_id": "S1481", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic int NumberOfMinutes(int hours)\n{\n  return hours * 60;\n}\n\n", "role_level": "MINOR", "role_title_en": "Unused local variables should be removed"},{"role_title": "在方法中仅用作局部变量的专用字段应成为局部变量.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Foo\n{\n  private int singularField;\n\n  public void DoSomething(int x)\n  {\n    singularField = x + 5;\n\n    if (singularField == 0) { /* ... */ }\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-1450", "role_id": "S1450", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Foo\n{\n  public void DoSomething(int x)\n  {\n    int localVariable = x + 5;\n\n    if (localVariable == 0) { /* ... */ }\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Private fields only used as local variables in methods should become local variables"},{"role_title": "布尔文字不应该是多余的.", "role_desc_en": "Redundant Boolean literals should be removed from expressions to improve readability.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (booleanMethod() == true) { /* ... */ }\nif (booleanMethod() == false) { /* ... */ }\nif (booleanMethod() || false) { /* ... */ }\ndoSomething(!false);\ndoSomething(booleanMethod() == true);\n\nbooleanVariable = booleanMethod() ? true : false;\nbooleanVariable = booleanMethod() ? true : exp;\nbooleanVariable = booleanMethod() ? false : exp;\nbooleanVariable = booleanMethod() ? exp : true;\nbooleanVariable = booleanMethod() ? exp : false;\n\nfor (var x = 0; true; x++)\n{\n ...\n}\n\n", "role_origin_id": "rule_RSPEC-1125", "role_id": "S1125", "role_desc": "应从表达式中删除冗余布尔文字以提高可读性.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif (booleanMethod()) { /* ... */ }        \nif (!booleanMethod()) { /* ... */ }\nif (booleanMethod()) { /* ... */ }\ndoSomething(true);\ndoSomething(booleanMethod());\n\nbooleanVariable = booleanMethod();\nbooleanVariable = booleanMethod() || exp;\nbooleanVariable = !booleanMethod() &amp;&amp; exp;\nbooleanVariable = !booleanMethod() || exp;\nbooleanVariable = booleanMethod() &amp;&amp; exp;\n\nfor (var x = 0; ; x++)\n{\n ...\n}\n\n", "role_level": "MINOR", "role_title_en": "Boolean literals should not be redundant"},{"role_title": "应该删除空的语句.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvoid doSomething() \n{\n  ; // Noncompliant - was used as a kind of TODO marker\n}\n\nvoid doSomethingElse() \n{\n  Console.WriteLine(\"Hello, world!\");;  // Noncompliant - double ;\n  ...\n  // Rarely, they are used on purpose as the body of a loop. It is a bad practice to \n  // have side-effects outside of the loop:\n  for (int i = 0; i &lt; 3; Console.WriteLine(i), i++); // Noncompliant\n  ...\n}\n\n", "role_origin_id": "rule_RSPEC-1116", "role_id": "S1116", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvoid doSomething() \n{\n}\n\nvoid doSomethingElse() \n{\n  Console.WriteLine(\"Hello, world!\");\n  ...\n  for (int i = 0; i &lt; 3; i++)\n  {\n    Console.WriteLine(i);\n   }\n  ...\n}\n\n", "role_level": "MINOR", "role_title_en": "Empty statements should be removed"},{"role_title": "文字后缀应为大写.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nconst long b = 0l;      // Noncompliant\n\n", "role_origin_id": "rule_RSPEC-818", "role_id": "S818", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nconst long b = 0L;\n\n", "role_level": "MINOR", "role_title_en": "Literal suffixes should be upper case"},{"role_title": "应该使用“Any（）”来测试空虚.", "role_desc_en": "Using .Count() to test for emptiness works, but using .Any() makes the intent clearer, and the code more readable. However, there are some cases where special attention should be paid:", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nprivate static bool HasContent(IEnumerable&lt;string&gt; strings)\n{\n  return strings.Count() &gt; 0;  // Noncompliant\n}\n\nprivate static bool HasContent2(IEnumerable&lt;string&gt; strings)\n{\n  return strings.Count() &gt;= 1;  // Noncompliant\n}\n\nprivate static bool IsEmpty(IEnumerable&lt;string&gt; strings)\n{\n  return strings.Count() == 0;  // Noncompliant\n}\n\n", "role_origin_id": "rule_RSPEC-1155", "role_id": "S1155", "role_desc": "运用.Count（）来测试空虚的工作，但使用.Any（）使意图更清晰，代码更可读.但是，有些情况要特别注意：.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nprivate static bool HasContent(IEnumerable&lt;string&gt; strings)\n{\n  return strings.Any();\n}\n\nprivate static bool IsEmpty(IEnumerable&lt;string&gt; strings)\n{\n  return !strings.Any();\n}\n\n", "role_level": "MINOR", "role_title_en": "\"Any()\" should be used to test for emptiness"},{"role_title": "“Equals”和比较运算符应该在实现“IComparable”时被覆盖.", "role_desc_en": "When you implement IComparable or IComparable&lt;T&gt; on a class you should also override Equals(object) and overload the comparison operators (==, !=, &lt;, &lt;=, &gt;, &gt;=). That's because the CLR cannot automatically call your CompareTo implementation from Equals(object) or from the base comparison operator implementations. Additionally, it is best practice to override GetHashCode along with Equals.This rule raises an issue when a class implements IComparable without also overriding Equals(object) and the comparison operators.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Foo: IComparable  // Noncompliant\n{\n  public int CompareTo(object obj) { /* ... */ }\n}\n\n", "role_origin_id": "rule_RSPEC-1210", "role_id": "S1210", "role_desc": "当您实现IComparable或IComparable＆lt; T＆gt;.这是因为CLR无法从Equals（object）或基本的比较运算符实现中自动调用CompareTo实现.另外，最好的做法是将GetHashCode与Equals一起重写.当一个类实现IComparable而不覆盖Equals（object）和比较运算符时，这个规则引发了一个问题.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Foo: IComparable\n{\n  public int CompareTo(object obj) { /* ... */ }\n  public override bool Equals(object obj)\n  {\n    var other = obj as Foo;\n    if (object.ReferenceEquals(other, null))\n    {\n      return false;\n    }\n    return this.CompareTo(other) == 0;\n  }\n  public int GetHashCode() { /* ... */ }\n  public static bool operator == (Foo left, Foo right) \n  {\n    if (object.ReferenceEquals(left, null))\n    {\n      return object.ReferenceEquals(right, null);\n    }\n    return left.Equals(right);\n  }\n  public static bool operator &gt; (Foo left, Foo right) \n  {\n    return Compare(left, right) &gt; 0;\n  }\n  public static bool operator &lt; (Foo left, Foo right) \n  {\n    return Compare(left, right) &lt; 0;\n  }\n  public static bool operator != (Foo left, Foo right) \n  {\n    return !(left == right);\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "\"Equals\" and the comparison operators should be overridden when implementing \"IComparable\""},{"role_title": "“Equals（Object）”和“GetHashCode（）”应该被成对重写.", "role_desc_en": "There is a contract between Equals(object) and GetHashCode(): If two objects are equal according to the Equals(object) method, then calling GetHashCode() on each of them must yield the same result. If this is not the case, many collections won't handle class instances correctly.In order to comply with the contract, Equals(object) and GetHashCode() should be either both inherited, or both overridden.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-1206", "role_id": "S1206", "role_desc": "Equals（object）和GetHashCode（）之间有一个契约：如果两个对象根据Equals（object）方法相等，那么每个对象的GetHashCode（）都必须产生相同的结果.如果不是这种情况，许多集合将不会正确处理类实例.为了遵守合同，Equals（object）和GetHashCode（）既可以被继承，也可以被覆盖.", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "\"Equals(Object)\" and \"GetHashCode()\" should be overridden in pairs"},{"role_title": "字段不应具有公共无障碍功能.", "role_desc_en": "Public fields in public classes do not respect the encapsulation principle and has three main disadvantages:By using private fields and public properties (set and get), unauthorized modifications are prevented. Properties also benefit from additional protection (security) features such as Link Demands.Note that due to optimizations on simple properties, public fields provide only very little performance gain.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Foo\n{\n    public int instanceData = 32; // Noncompliant\n}\n\n", "role_origin_id": "rule_RSPEC-1104", "role_id": "S1104", "role_desc": "公共场所公共场所不尊重封装原则，主要有三个缺点：.通过使用私有域和公共属性（设置和获取），可以防止未经授权的修改.属性还受益于附加保护（安全）功能，如链接要求.请注意，由于对简单属性的优化，公共字段的性能提升只有很小.", "role_type": "Vulnerability", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Foo\n{\n    private int instanceData = 32;\n\n    public int InstanceData\n    {\n        get { return instanceData; }\n\tset { instanceData = value ; }\n    }\n}\n\n", "role_level": "MINOR", "role_title_en": "Fields should not have public accessibility"},{"role_title": "通用异常不应该被忽略.", "role_desc_en": "When exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them.This rule only reports on empty catch clauses that catch generic {{Exception}}s.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nstring text = \"\";\ntry \n{\n  text = File.ReadAllText(fileName);\n} \ncatch (Exception exc) // Noncompliant\n{  \n}\n\n", "role_origin_id": "rule_RSPEC-2486", "role_id": "S2486", "role_desc": "当发生异常时，简单地忽略它们通常是一个坏主意.相反，最好是妥善处理它们，或至少记录它们.此规则仅报告捕获泛型{{Exception}}的空catch子句.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nstring text = \"\";\ntry \n{\n  text = File.ReadAllText(fileName);\n} \ncatch (Exception exc) \n{\n  logger.Log(exc);\n}\n\n", "role_level": "MINOR", "role_title_en": "Generic exceptions should not be ignored"},{"role_title": "继承列表不应该是冗余的.", "role_desc_en": "An inheritance list entry is redundant if:Such redundant declarations should be removed because they needlessly clutter the code and can be confusing.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class MyClass : Object  // Noncompliant\n\nenum MyEnum : int", "role_origin_id": "rule_RSPEC-1939", "role_id": "S1939", "role_desc": "如果以下情况，继承列表条目是多余的：.应该删除这些冗余的声明，因为它们不必要地混淆代码并且可能会令人困惑.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Inheritance list should not be redundant"},