{"role_title": "覆盖成员应该做的不仅仅是在基类中调用同一个成员.", "role_desc_en": "Overriding a method just to call the same method from the base class without performing any other actions is useless and misleading. The only time this is justified is in sealed overriding methods, where the effect is to lock in the parent class behavior. This rule ignores overrides of Equals and GetHashCode.NOTE: In some cases it might be dangerous to add or remove empty overrides, as they might be breaking changes.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic override void Method() // Noncompliant\n{\n  base.Method(); \n}\n\n", "role_origin_id": "rule_RSPEC-1185", "role_id": "S1185", "role_desc": "覆盖一个方法只是从基类调用相同的方法而不执行任何其他操作是无用的和误导的.唯一有理由的是在封闭的重写方法中，其效果是锁定父类行为.此规则忽略等于和GetHashCode的覆盖.注意：在某些情况下，添加或删除空覆盖可能是危险的，因为它们可能会损坏更改.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic override void Method()\n{\n  //do something else\n}\n\n", "role_level": "MINOR", "role_title_en": "Overriding members should do more than simply call the same member in the base class"},{"role_title": "整数除法的结果不应该分配给浮点变量.", "role_desc_en": "When division is performed on int}}s, the result will always be an {{int. You can assign that result to a double, float or decimal with automatic type conversion, but having started as an int, the result will likely not be what you expect. If the result of int division is assigned to a floating-point variable, precision will have been lost before the assignment. Instead, at least one operand should be cast or promoted to the final type before the operation takes place.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nstatic void Main()\n{\n  decimal dec = 3/2; // Noncompliant\n  Method(3/2); // Noncompliant\n}\n\nstatic void Method(float f) { }\n\n", "role_origin_id": "rule_RSPEC-2184", "role_id": "S2184", "role_desc": "当在int}}上执行除法时，结果将始终为{{int.您可以将该结果分配给具有自动类型转换的double，float或decimal，但是以int开头，结果可能不会是您期望的结果.如果将int除法的结果分配给浮点变量，则在赋值之前精度将会丢失.相反，在操作发生之前，至少应该将一个操作数转换或提升为最终类型.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nstatic void Main()\n{\n  decimal dec = (decimal)3/2;\n  Method(3.0F/2);\n}\n\nstatic void Method(float f) { }\n\n", "role_level": "MINOR", "role_title_en": "Results of integer division should not be assigned to floating point variables"},{"role_title": "应该简化运行时类型检查.", "role_desc_en": "To check the type of an object there are several options:If runtime calculated {{Type}}s need to be compared:Depending on whether the type is returned by a GetType() or typeof() call, the IsAssignableFrom() and IsInstanceOfType() might be simplified. Similarly, if the type is sealed, the type comparison with == can be converted to an is call. Simplifying the calls also make null checking unnecessary because both is and IsInstanceOfType performs it already.Finally, utilizing the most concise language constructs for type checking makes the code more readable, so", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass Fruit { }\nsealed class Apple : Fruit { }\n\nclass Program\n{\n  static void Main()\n  {\n    var apple = new Apple();\n    var b = apple != null &amp;&amp; apple.GetType() == typeof (Apple); // Noncompliant\n    b = typeof(Apple).IsInstanceOfType(apple); // Noncompliant\n    if (apple != null)\n    {\n      b = typeof(Apple).IsAssignableFrom(apple.GetType()); // Noncompliant\n    }\n    var appleType = typeof (Apple);\n    if (apple != null)\n    {\n      b = appleType.IsAssignableFrom(apple.GetType()); // Noncompliant\n    }\n\n    Fruit f = apple;\n    if (f as Apple != null) // Noncompliant\n    {\n    }\n    if (apple is Apple) // Noncompliant\n    {\n    }\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2219", "role_id": "S2219", "role_desc": "要检查对象的类型有几个选项：.如果运行时计算{{Type}}需要比较：.根据GetType（）或typeof（）调用返回的类型，IsAssignableFrom（）和IsInstanceOfType（）可能被简化.类似地，如果类型是密封的，与==的类型比较可以转换为一个调用.简化呼叫也使得空检查不必要，因为IsInstanceOfType都已经执行了.最后，利用最简洁的语言结构进行类型检查，使代码更易读.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass Fruit { }\nsealed class Apple : Fruit { }\n\nclass Program\n{\n  static void Main()\n  {\n    var apple = new Apple();\n    var b = apple is Apple;\n    b = apple is Apple;\n    b = apple is Apple;\n    var appleType = typeof(Apple);\n    b = appleType.IsInstanceOfType(apple);\n\n    Fruit f = apple;\n    if (f is Apple)\n    {\n    }\n    if (apple != null)\n    {\n    }\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Runtime type checking should be simplified"},{"role_title": "类型应在骆驼案中命名.", "role_desc_en": "Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not type names are camel cased. To reduce noise, two consecutive upper case characters are allowed unless they form the whole type name. So, MyXClass is compliant, but XC on its own is not.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass my_class {...}\nclass SOMEName42 {...}\n\n", "role_origin_id": "rule_RSPEC-101", "role_id": "S101", "role_desc": "共享命名约定允许团队有效协作.此规则检查类型名称是否为骆驼套装.为了减少噪音，除非形成整个类型名称，否则允许连续使用两个大写字母.所以，MyXClass是兼容的，但XC本身就不是.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass MyClass {...}\nclass SomeName42 {...}\n\n", "role_level": "MINOR", "role_title_en": "Types should be named in camel case"},{"role_title": "调用者信息参数不应被明确提供.", "role_desc_en": "Caller information attributes: CallerFilePathAttribute and CallerLineNumberAttribute provide a way to get information about the caller of a method through optional parameters. But the arguments for these optional parameters are only generated if they are not explicitly defined in the call. Thus, specifying the argument values defeats the purpose of the attributes.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvoid TraceMessage(string message,\n  [CallerFilePath] string filePath = null,\n  [CallerLineNumber] int lineNumber = 0)\n{\n  /* ... */\n}\n\nvoid MyMethod()\n{\n  TraceMessage(\"my message\", \"A.B.C.Foo.cs\", 42); // Noncompliant\n}\n\n", "role_origin_id": "rule_RSPEC-3236", "role_id": "S3236", "role_desc": "来电者信息属性：CallerFilePathAttribute和CallerLineNumberAttribute提供了一种通过可选参数获取有关方法调用方的信息的方法.但是，这些可选参数的参数仅在调用中未明确定义时生成.因此，指定参数值会击败属性的目的.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvoid TraceMessage(string message,\n  [CallerFilePath] string filePath = \"\",\n  [CallerLineNumber] int lineNumber = 0)\n{\n  /* ... */\n}\n\nvoid MyMethod()\n{\n  TraceMessage(\"my message\");\n}\n\n", "role_level": "MINOR", "role_title_en": "Caller information arguments should not be provided explicitly"},{"role_title": "重复的演员不应该做.", "role_desc_en": "Because the is operator performs a cast if the object is not null, using is to check type and then casting the same argument to that type, necessarily performs two casts. The same result can be achieved more efficiently with a single cast using as, followed by a null-check.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (x is Fruit)  // Noncompliant\n{\n  var f = (Fruit)x; // or x as Fruit\n  // ...\n}\n\n", "role_origin_id": "rule_RSPEC-3247", "role_id": "S3247", "role_desc": "因为如果对象不为null，则操作符执行一个转换，使用是检查类型，然后将相同的参数转换为该类型，必须执行两个转换.使用单个演员使用，然后进行空值检查，可以更有效地实现相同的结果.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvar f = x as Fruit;\nif (f != null)\n{\n  // code\n}\n\n", "role_level": "MINOR", "role_title_en": "Duplicate casts should not be made"},{"role_title": "应为“部分”方法提供实施.", "role_desc_en": "partial methods allow an increased degree of flexibility in programming a system. Hooks can be added to generated code by invoking methods that define their signature, but might not have an implementation yet. But if the implementation is still missing when the code makes it to production, the compiler silently removes the call. In the best case scenario, such calls simply represent cruft, but in they worst case they are critical, missing functionality, the loss of which will lead to unexpected results at runtime.This rule raises an issue for partial methods for which no implementation can be found in the assembly.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npartial class C\n{\n  partial void M(); //Noncompliant\n\n  void OtherM()\n  {\n    M(); //Noncompliant. Will be removed.\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3251", "role_id": "S3251", "role_desc": "部分方法允许在编程系统时提高程度的灵活性.可以通过调用定义其签名的方法将Hooks添加到生成的代码中，但可能还没有实现.但是，如果代码使其生成时仍然缺少实现，则编译器将静默地删除该调用.在最好的情况下，这样的呼叫只是表示cruft，但在最坏的情况下，它们是关键的，缺少功能，其丢失将导致运行时的意外结果.此规则引发了在程序集中无法找到实现的部分方法的问题.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Implementations should be provided for \"partial\" methods"},{"role_title": "接口不应该简单地从具有冲突成员的基础接口继承.", "role_desc_en": "When an interface inherits from two interfaces that both define a member with the same name, trying to access that member through the derived interface will result in the compiler error CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'.So instead, every caller will be forced to cast instances of the derived interface to one or the other of its base interfaces to resolve the ambiguity and be able to access the member. Instead, it is better to resolve the ambiguity in the definition of the derived interface either by:", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic interface IBase1\n{\n  string SomeProperty { get; set; }\n}\n\npublic interface IBase2\n{\n  string SomeProperty { get; set; }\n}\n\npublic interface IDerived : IBase1, IBase2 // Noncompliant, accessing IDerived.SomeProperty is ambiguous\n{\n}\n\npublic class MyClass : IDerived\n{\n  // Implements both IBase1.SomeProperty and IBase2.SomeProperty\n  public string SomeProperty { get; set; } = \"Hello\";\n\n  public static void Main()\n  {\n    MyClass myClass = new MyClass();\n    Console.WriteLine(myClass.SomeProperty); // Writes \"Hello\" as expected\n    Console.WriteLine(((IBase1)myClass).SomeProperty); // Writes \"Hello\" as expected\n    Console.WriteLine(((IBase2)myClass).SomeProperty); // Writes \"Hello\" as expected\n    Console.WriteLine(((IDerived)myClass).SomeProperty); // Error CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3444", "role_id": "S3444", "role_desc": "当接口从两个定义同名成员的接口继承时，尝试通过派生接口访问该成员将导致编译器错误CS0229'IBase1之间的歧义.SomeProperty'和'IBase2.SomeProperty”.所以相反，每个调用者将被迫将衍生接口的实例转移到其基础接口中的一个或另一个，以解决歧义，并且能够访问该成员.相反，最好是通过以下方式解决派生界面的定义中的歧义：.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic interface IDerived : IBase1, IBase2\n{\n  new string SomeProperty { get; set; }\n}\n\npublic class MyClass : IDerived\n{\n  // Implements IBase1.SomeProperty, IBase2.SomeProperty and IDerived.SomeProperty\n  public string SomeProperty { get; set; } = \"Hello\";\n\n  public static void Main()\n  {\n    MyClass myClass = new MyClass();\n    Console.WriteLine(myClass.SomeProperty); // Writes \"Hello\" as expected\n    Console.WriteLine(((IBase1)myClass).SomeProperty); // Writes \"Hello\" as expected\n    Console.WriteLine(((IBase2)myClass).SomeProperty); // Writes \"Hello\" as expected\n    Console.WriteLine(((IDerived)myClass).SomeProperty); // Writes \"Hello\" as expected\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Interfaces should not simply inherit from base interfaces with colliding members"},{"role_title": "跳转语句不应该是多余的.", "role_desc_en": "Jump statements, such as return, yield break, goto, and continue let you change the default flow of program execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvoid Foo()\n{\n  goto A; // Noncompliant\n  A:\n  while (condition1)\n  {\n    if (condition2)\n    {\n      continue; // Noncompliant\n    }\n    else\n    {\n      DoTheThing();\n    }\n  }\n  return; // Noncompliant; this is a void method\n}\n\n", "role_origin_id": "rule_RSPEC-3626", "role_id": "S3626", "role_desc": "跳转语句，如return，yield break，goto，并继续让您更改程序执行的默认流程，但将控制流引导到原始方向的跳转语句只是浪费击键.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvoid Foo()\n{\n  while (condition1)\n  {\n    if (!condition2)\n    {\n      DoTheThing();\n    }\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Jump statements should not be redundant"},{"role_title": "成员初始化值不应该是多余的.", "role_desc_en": "Fields, properties and events can be initialized either inline or in the constructor. Initializing them inline and in the constructor at the same time is redundant; the inline initialization will be overridden.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass Person\n{\n  int age = 42; // Noncompliant\n  public Person(int age)\n  {\n    this.age = age;\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3604", "role_id": "S3604", "role_desc": "字段，属性和事件可以内联或构造函数初始化.同时初始化它们在构造函数中是多余的;.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass Person\n{\n  int age;\n  public Person(int age)\n  {\n    this.age = age;\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Member initializer values should not be redundant"},{"role_title": "方法调用不应该模糊地解释为重载“params”.", "role_desc_en": "The rules for method resolution are complex and perhaps not properly understood by all coders. The params keyword can make method declarations overlap in non-obvious ways, so that slight changes in the argument types of an invocation can resolve to different methods.This rule raises an issue when an invocation resolves to a method declaration with params, but could also resolve to another non-params method too.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class MyClass\n{\n  private void Format(string a, params object[] b) { }\n\n  private void Format(object a, object b, object c) { }\n}\n\n// ...\nMyClass myClass = new MyClass();\n\nmyClass.Format(\"\", null, null); //Noncompliant, resolves to the first Format with params, but was that intended?\n\n", "role_origin_id": "rule_RSPEC-3220", "role_id": "S3220", "role_desc": "方法解决的规则是复杂的，也可能没有被所有编码人员正确理解.params关键字可以使方法声明以非常明显的方式重叠，因此调用的参数类型的轻微更改可以解析为不同的方法.当调用解析为具有params的方法声明时，此规则引发了一个问题，但也可以将其解析为另一个非params方法.", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Method calls should not resolve ambiguously to overloads with \"params\""},{"role_title": "方法不应该返回从未使用过的值.", "role_desc_en": "Private methods are clearly intended for use only within their own scope. When such methods return values that are never used by any of their callers, then clearly there is no need to actually make the return, and it should be removed in the interests of efficiency and clarity. ", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-3241", "role_id": "S3241", "role_desc": "私人方法明确仅在其范围内使用.当这些方法返回从未被任何一个呼叫者使用的值时，显然没有必要实际返回，为了效率和清晰度而应该删除它.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Methods should not return values that are never used"},{"role_title": "可变的非私人字段不应该是“只读”.", "role_desc_en": "Using the readonly keyword on a field means that it can't be changed after initialization. However, when applied to collections or arrays, that's only partly true. readonly enforces that another instance can't be assigned to the field, but it cannot keep the contents from being updated. That  means that in practice, the field value really can be changed, and the use of readonly on such a field is misleading, and you're likely to not be getting the behavior you expect.This rule raises an issue when a non-private, readonly field is an array or collection.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class MyClass\n{\n  public readonly string[] strings;  // Noncompliant\n\n  // ...\n\n", "role_origin_id": "rule_RSPEC-3887", "role_id": "S3887", "role_desc": "在字段上使用readonly关键字意味着在初始化后不能更改.然而，当应用于集合或数组时，这仅仅是部分的.readonly强制另一个实例不能分配到该字段，但它不能保持内容不被更新.这意味着在实践中，现场价值实际上可以改变，在这样一个领域的readonly的使用是误导的，你可能不会得到你期望的行为.当非私有的只读字段是数组或集合时，此规则引发了一个问题.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class MyClass\n{\n  public string[] strings;\n\n  // ...\n\n", "role_level": "MINOR", "role_title_en": "Mutable, non-private fields should not be \"readonly\""},{"role_title": "命名空间不应该是空的.", "role_desc_en": "Namespaces with no lines of code clutter a project and should be removed. ", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nnamespace MyEmptyNamespace // Noncompliant\n{\n\n}\n\n", "role_origin_id": "rule_RSPEC-3261", "role_id": "S3261", "role_desc": "没有代码行的命名空间使项目混乱，应该被删除.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Namespaces should not be empty"},{"role_title": "具有“[DefaultParameterValue]”属性的参数也应标记为“[可选]”.", "role_desc_en": "There is no point in providing a default value for a parameter if callers are required to provide a value for it anyway. Thus, [DefaultParameterValue] should always be used in conjunction with [Optional].", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic void MyMethod([DefaultParameterValue(5)] int j) //Noncompliant, useless\n{\n  Console.WriteLine(j);\n}\n\n", "role_origin_id": "rule_RSPEC-3450", "role_id": "S3450", "role_desc": "如果呼叫者需要为其提供值，则无需为参数提供默认值.因此，[DefaultParameterValue]应始终与[可选]结合使用.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic void MyMethod(int j = 5)\n{\n  Console.WriteLine(j);\n}\n\n", "role_level": "MINOR", "role_title_en": "Parameters with \"[DefaultParameterValue]\" attributes should also be marked \"[Optional]\""},{"role_title": "属性分配不应该仅用于“只读”字段，而不限于引用类型.", "role_desc_en": "While the properties of a readonly reference type field can still be changed after initialization, those of a readonly value field, such as a struct, cannot. If the member could be either a class or a struct then assignment to its properties could be unreliable, working sometimes but not others.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\ninterface IPoint\n{\n  int X { get; set; }\n  int Y { get; set; }\n}\n\nclass PointManager&lt;T&gt; where T: IPoint \n{\n  readonly T point;  // this could be a struct\n  public PointManager(T point)\n  {\n    this.point = point;\n  }\n\n  public void MovePointVertically(int newX)\n  {\n    point.X = newX; //Noncompliant; if point is a struct, then nothing happened\n    Console.WriteLine(point.X);\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2934", "role_id": "S2934", "role_desc": "虽然只读引用类型字段的属性在初始化后仍然可以更改，但只读值字段（如struct）的属性不能.如果该成员可以是一个类或一个结构体，那么其属性的赋值可能是不可靠的，有时而不是其他的.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\ninterface IPoint\n{\n  int X { get; set; }\n  int Y { get; set; }\n}\n\nclass PointManager&lt;T&gt; where T : IPoint \n{\n  readonly T point;  // this could be a struct\n  public PointManager(T point)\n  {\n    this.point = point;\n  }\n\n  public void MovePointVertically(int newX) // assignment has been removed\n  {\n    Console.WriteLine(point.X);\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Property assignments should not be made for \"readonly\" fields not constrained to reference types"},{"role_title": "琐碎的属性应该是自动实现的.", "role_desc_en": "Trivial properties, which include no logic but setting and getting a backing field should be converted to auto-implemented properties, yielding cleaner and more readable code.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Car \n{\n  private string _make;\n  public string Make // Noncompliant\n  {\n    get { return _make; }\n    set { _make = value; }\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2292", "role_id": "S2292", "role_desc": "包括无逻辑但设置和获取支持字段的简单属性应转换为自动实现的属性，从而产生更清晰和更可读的代码.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Car \n{\n  public string Make { get; set; }\n}\n\n", "role_level": "MINOR", "role_title_en": "Trivial properties should be auto-implemented"},{"role_title": "未分配的成员应该被删除.", "role_desc_en": "Fields and auto-properties that are never assigned to hold the default values for their types. They are either pointless code or, more likely, mistakes. ", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass MyClass\n{\n  private int field; // Noncompliant, shouldn't it be initialized? This way the value is always default(int), 0.\n  private int Property { get; set; }  // Noncompliant\n  public void Print()\n  {\n    Console.WriteLine(field); //Will always print 0\n    Console.WriteLine(Property); //Will always print 0\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3459", "role_id": "S3459", "role_desc": "从未分配的字段和自动属性用于保存其类型的默认值.他们是无意义的代码，或者更可能是错误.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass MyClass\n{\n  private int field;\n  private int Property { get; set; } = 42;\n  public void Print()\n  {\n    field++;\n    Console.WriteLine(field);\n    Console.WriteLine(Property);\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Unassigned members should be removed"},{"role_title": "变量不应该被检查与它们即将分配的值.", "role_desc_en": "There's no point in checking a variable against the value you're about to assign it. Save the cycles and lines of code, and simply perform the assignment.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (x != a)  // Noncompliant; why bother?\n{\n  x = a;\n}\n\n", "role_origin_id": "rule_RSPEC-3440", "role_id": "S3440", "role_desc": "根据您要分配的值检查变量没有任何意义.保存循环和代码行，并简单地执行分配.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nx = a;\n\n", "role_level": "MINOR", "role_title_en": "Variables should not be checked against the values they're about to be assigned"},{"role_title": "跟踪“TODO”标签的使用.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nprivate void DoSomething() \n{\n  // TODO\n}\n\n", "role_origin_id": "rule_RSPEC-1135", "role_id": "S1135", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": null, "role_title_en": "Track uses of \"TODO\" tags"},{"role_title": "子类字段不应该隐藏父类字段.", "role_desc_en": "", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-2387", "role_id": "S2387", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "BLOCKER", "role_title_en": "Child class fields should not shadow parent class fields"},{"role_title": "跟踪版权和许可证标题缺乏.", "role_desc_en": "Each source file should start with a header stating file ownership and the license which must be used to distribute the application. \nThis rule must be fed with the header text that is expected at the beginning of every file.The headerFormat must end with an empty line if you want to have an empty line between the file header and the first line for your source file (using, namespace...).For example, if you want the source file to look like thisthen the headerFormat parameter should end with an empty line like this", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-1451", "role_id": "S1451", "role_desc": "每个源文件都应以标题说明文件所有权和必须用于分发应用程序的许可证开头.必须使用预期在每个文件开头的标题文本来提供此规则.如果要在文件头和源文件的第一行之间有空行，则headerFormat必须以空行结尾（使用命名空间.）.例如，如果您希望源文件看起来像这样.那么headerFormat参数应该以这样的空行结束.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "BLOCKER", "role_title_en": "Track lack of copyright and license headers"},{"role_title": "“IDisposable”成员的类应该实现“IDisposable”.", "role_desc_en": "Classes with IDisposable members are responsible for cleaning up those members by calling their Dispose methods. The best practice here is for the owning class to itself implement IDisposable and call its members' Dispose methods from its own Dispose method.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class ResourceHolder   // Noncompliant; doesn't implement IDisposable\n{\n  private FileStream fs;  // This member is never Dispose'd\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open);\n  }\n  public void CloseResource()\n  {\n    this.fs.Close();\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2931", "role_id": "S2931", "role_desc": "具有IDisposable成员的课程负责通过调用Dispose方法来清理那些成员.这里的最佳做法是让拥有类自己实现IDisposable，并从其自己的Dispose方法中调用其成员的Dispose方法.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class ResourceHolder : IDisposable \n{ \n  private FileStream fs; \n  public void OpenResource(string path) \n  { \n    this.fs = new FileStream(path, FileMode.Open); \n  } \n  public void CloseResource() \n  { \n    this.fs.Close(); \n  } \n\n  public void Dispose() \n  { \n    this.fs.Dispose(); \n  } \n} \n\n", "role_level": "BLOCKER", "role_title_en": "Classes with \"IDisposable\" members should implement \"IDisposable\""},{"role_title": "应该使用“ConfigureAwait（false）”.", "role_desc_en": "After an await}}ed {{Task has executed, you can continue execution in the original, calling thread or any arbitrary thread. Unless the rest of the code needs the context from which the Task was spawned, Task.ConfigureAwait(false) should be used to keep execution in the Task thread to avoid the need for context switching and the possibility of deadlocks.This rule raises an issue when code in a class library await}}s a {{Task and continues execution in the original calling thread.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvar response = await httpClient.GetAsync(url);  // Noncompliant\n\n", "role_origin_id": "rule_RSPEC-3216", "role_id": "S3216", "role_desc": "在等待之后}} ed {{Task已执行，您可以继续执行原始，调用线程或任意任意的线程.除非代码的其余部分需要任务生成的上下文，否则任务.应该使用ConfigureAwait（false）来执行任务线程，以避免上下文切换的需要和死锁的可能性.这个规则在类库中的代码中引发了一个问题await}} s {{任务并继续在原来的调用线程中执行.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvar response = await httpClient.GetAsync(url).ConfigureAwait(false);\n\n", "role_level": "CRITICAL", "role_title_en": "\"ConfigureAwait(false)\" should be used"},{"role_title": "“接口”实例不应该被转换为具体类型.", "role_desc_en": "Needing to cast from an interface to a concrete type indicates that something is wrong with the abstractions in use, likely that something is missing from the interface. Instead of casting to a discrete type, the missing functionality should be added to the interface. Otherwise there is a risk of runtime exceptions.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic interface IMyInterface\n{\n  void DoStuff();\n}\n\npublic class MyClass1 : IMyInterface\n{\n  public int Data { get { return new Random().Next(); } }\n\n  public void DoStuff()\n  {\n    // TODO...\n  }\n}\n\npublic static class DowncastExampleProgram\n{\n  static void EntryPoint(IMyInterface interfaceRef)\n  {\n    MyClass1 class1 = (MyClass1)interfaceRef;  // Noncompliant\n    int privateData = class1.Data;\n\n    class1 = interfaceRef as MyClass1;  // Noncompliant\n    if (class1 != null)\n    {\n      // ...\n    }\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3215", "role_id": "S3215", "role_desc": "需要从界面转换为具体类型表示使用中的抽象有问题，可能是界面中缺少某些东西.而不是转换为离散类型，缺少的功能应该添加到接口.否则存在运行时异常的风险.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "CRITICAL", "role_title_en": "\"interface\" instances should not be cast to concrete types"},{"role_title": "“out”和“ref”参数不应该使用.", "role_desc_en": "Passing a parameter by reference, which is what happens when you use the out or ref parameter modifiers, means that the method will receive a pointer to the argument, rather than the argument itself. If the argument was a value type, the method will be able to change the argument's values. If it was a reference type, then the method receives a pointer to a pointer, which is usually not what was intended. Even when it is what was intended, this is the sort of thing that's difficult to get right, and should be used with caution.This rule raises an issue when out or ref is used on a non-Optional parameter in a public method. Optional parameters are covered by S3447.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic void GetReply(\n         ref MyClass input, // Noncompliant\n         out string reply)  // Noncompliant\n{ ... }\n\n", "role_origin_id": "rule_RSPEC-3874", "role_id": "S3874", "role_desc": "通过引用传递参数，当使用out或ref参数修饰符时会发生什么，意味着该方法将接收到参数的指针，而不是参数本身.如果参数是值类型，则该方法将能够更改参数的值.如果它是一个引用类型，那么该方法会接收一个指向指针的指针，这通常不是预期的.即使是想要的东西，这是很难得到的东西，应谨慎使用.当在公共方法中的非可选参数使用out或ref时，此规则引发了一个问题.可选参数由S3447涵盖.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic string GetReply(MyClass input)\n{ ... }\n\npublic bool TryGetReply(MyClass input, out string reply)\n{ ... }\n\npublic ReplyData GetReply(MyClass input)\n{ ... }\n\ninternal void GetReply(ref MyClass input, out string reply) \n{ ... }\n\n", "role_level": "CRITICAL", "role_title_en": "\"out\" and \"ref\" parameters should not be used"},{"role_title": "不应使用阵列协方差.", "role_desc_en": "Array covariance is the principle that if an implicit or explicit reference conversion exits from type A to B, then the same conversion exists from the array type A[] to B[].While this array conversion can be useful in readonly situations to pass instances of A[] where B[] is expected, it must be used with care, since assigning an instance of B into an array of A will cause an ArrayTypeMismatchException to be thrown at runtime.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nabstract class Fruit { }\nclass Apple : Fruit { }\nclass Orange : Fruit { }\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    Fruit[] fruits = new Apple[1]; // Noncompliant - array covariance is used\n    FillWithOranges(fruits);\n  }\n\n  // Just looking at the code doesn't reveal anything suspicious\n  static void FillWithOranges(Fruit[] fruits)\n  {\n    for (int i = 0; i &lt; fruits.Length; i++)\n    {\n      fruits[i] = new Orange(); // Will throw an ArrayTypeMismatchException\n    }\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2330", "role_id": "S2330", "role_desc": "数组协方差是原则，如果隐式或显式引用转换退出A类到B类，那么从数组类型A []到B []存在相同的转换.虽然这种数组转换在只读状况下可以有效地传递需要B []的A []的实例，但必须谨慎使用，因为将B的实例分配到A的数组将导致ArrayTypeMismatchException抛出.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nabstract class Fruit { }\nclass Apple : Fruit { }\nclass Orange : Fruit { }\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    Orange[] fruits = new Orange[1]; // Compliant\n    FillWithOranges(fruits);\n  }\n\n  static void FillWithOranges(Orange[] fruits)\n  {\n    for (int i = 0; i &lt; fruits.Length; i++)\n    {\n      fruits[i] = new Orange();\n    }\n  }\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Array covariance should not be used"},{"role_title": "分支机构应通过单位测试具有足够的覆盖面.", "role_desc_en": "An issue is created on a file as soon as the branch coverage on this file is less than the required threshold. It gives the number of branches to be covered in order to reach the required threshold.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-1482", "role_id": "S1482", "role_desc": "一旦文件的分支覆盖率小于所需阈值，就会在文件上创建一个问题.它给出要覆盖的分支数量以达到所需的阈值.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Branches should have sufficient coverage by unit tests"},{"role_title": "不能使用可选参数.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvoid Notify(string company, string office = \"QJZ\") // Noncompliant\n{\n}\n\n", "role_origin_id": "rule_RSPEC-2360", "role_id": "S2360", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvoid Notify(string company)\n{\n  Notify(company, \"QJZ\");\n}\nvoid Notify(string company, string office)\n{\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Optional parameters should not be used"},{"role_title": "公共常数成员不应该被使用.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Foo\n{\n    public const double Version = 1.0;           // Noncompliant\n}\n\n", "role_origin_id": "rule_RSPEC-2339", "role_id": "S2339", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Foo\n{\n    public static double Version \n    {\n      get { return 1.0; }\n    }\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Public constant members should not be used"},{"role_title": "不应检查模数结果是否直接相等.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic bool IsOdd(int x) \n{\n  return x % 2 == 1;  // Noncompliant; if x is an odd negative, x % 2 == -1\n}\n\n", "role_origin_id": "rule_RSPEC-2197", "role_id": "S2197", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic bool IsOdd(int x) \n{\n  return x %2 != 0;\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Modulus results should not be checked for direct equality"},{"role_title": "不应使用SHA-1和消息摘要散列算法.", "role_desc_en": "The MD5 algorithm and its successor, SHA-1, are no longer considered secure, because it is too easy to create hash collisions with them. That is, it takes too little computational effort to come up with a different input that produces the same MD5 or SHA-1 hash, and using the new, same-hash value gives an attacker the same access as if he had the originally-hashed value. This applies as well to the other Message-Digest algorithms: MD2, MD4, MD6.This rule tracks usage of the System.Security.Cryptography.CryptoConfig.CreateFromName(), and System.Security.Cryptography.HashAlgorithm.Create() methods to instantiate MD5 or SHA-1 algorithms, and of derived class instances of System.Security.Cryptography.SHA1 and System.Security.Cryptography.MD5.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvar hashProvider1 = new MD5CryptoServiceProvider(); //Noncompliant\nvar hashProvider2 = (HashAlgorithm)CryptoConfig.CreateFromName(\"MD5\"); //Noncompliant\nvar hashProvider3 = new SHA1Managed(); //Noncompliant\nvar hashProvider4 = HashAlgorithm.Create(\"SHA1\"); //Noncompliant\n\n", "role_origin_id": "rule_RSPEC-2070", "role_id": "S2070", "role_desc": "MD5算法及其后继SHA-1不再被认为是安全的，因为它们太容易与它们创建哈希冲突.也就是说，需要太少的计算量来产生产生相同MD5或SHA-1散列的不同输入，并且使用新的相同散列值给予攻击者相同的访问，就像他原来是散列的.这也适用于其他消息摘要算法：MD2，MD4，MD6.该规则跟踪系统的使用情况.安全.加密.CryptoConfig.CreateFromName（）和System.安全.加密.的HashAlgorithm.Create（）方法来实例化MD5或SHA-1算法，以及System派生类实例.安全.加密.SHA1和系统.安全.加密.MD5.", "role_type": "Vulnerability", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvar hashProvider1 = new SHA256Managed();\nvar hashProvider2 = (HashAlgorithm)CryptoConfig.CreateFromName(\"SHA256Managed\");\nvar hashProvider3 = HashAlgorithm.Create(\"SHA256Managed\");\n\n", "role_level": "CRITICAL", "role_title_en": "SHA-1 and Message-Digest hash algorithms should not be used"},{"role_title": "“for”循环递增子句应该修改循环计数器.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nfor (i = 0; i &lt; 10; j++) // Noncompliant\n{  \n  // ...\n}\n\n", "role_origin_id": "rule_RSPEC-1994", "role_id": "S1994", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nfor (i = 0; i &lt; 10; i++)\n{\n  // ...\n}\n\n", "role_level": "CRITICAL", "role_title_en": "\"for\" loop increment clauses should modify the loops' counters"},{"role_title": "表达式不应太复杂.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (((condition1 &amp;&amp; condition2) || (condition3 &amp;&amp; condition4)) &amp;&amp; condition5) { ... } \n\n", "role_origin_id": "rule_RSPEC-1067", "role_id": "S1067", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif ((MyFirstCondition() || MySecondCondition()) &amp;&amp; MyLastCondition()) { ... }     \n\n", "role_level": "CRITICAL", "role_title_en": "Expressions should not be too complex"},{"role_title": "“如果.否则“结构应以”else“子句结尾.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (x == 0) \n{\n  doSomething();\n} else if (x == 1) \n{\n  doSomethingElse();\n} \n\n", "role_origin_id": "rule_RSPEC-126", "role_id": "S126", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif (x == 0) \n{\n  doSomething();\n} else if (x == 1) \n{\n  doSomethingElse();\n} else \n{\n  throw new IllegalStateException();\n}\n\n", "role_level": "CRITICAL", "role_title_en": "\"if ... else if\" constructs should end with \"else\" clauses"},{"role_title": "控制结构应使用花括号.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\n// the two statements seems to be attached to the if statement, but that is only true for the first one:\nif (condition)\n  ExecuteSomething();\n  CheckSomething();\n\n", "role_origin_id": "rule_RSPEC-121", "role_id": "S121", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif (condition)\n{\n  ExecuteSomething();\n  CheckSomething();\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Control structures should use curly braces"},{"role_title": "“switch / Select”语句应以“default / Case Else”子句结尾.", "role_desc_en": "The requirement for a final default clause is defensive programming. The clause should either take appropriate action, or contain a suitable comment as to why no action is taken. Even when the switch covers all current values of an enum, a default case should still be used because there is no guarantee that the enum won't be extended.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nint foo = 42;\nswitch (foo) // Noncompliant\n{\n  case 0:\n    Console.WriteLine(\"foo = 0\");\n    break;\n  case 42:\n    Console.WriteLine(\"foo = 42\");\n    break;\n}\n\n", "role_origin_id": "rule_RSPEC-131", "role_id": "S131", "role_desc": "最后的默认条款的要求是防御性编程.该条款应采取适当行动，或包含适当的评论，为什么不采取任何行动.即使交换机覆盖了枚举的所有当前值，仍应使用默认情况，因为不能保证枚举不会被扩展.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nint foo = 42;\nswitch (foo) // Compliant\n{\n  case 0:\n    Console.WriteLine(\"foo = 0\");\n    break;\n  case 42:\n    Console.WriteLine(\"foo = 42\");\n    break;\n  default:\n    throw new InvalidOperationException(\"Unexpected value foo = \" + foo);\n}\n\n", "role_level": "CRITICAL", "role_title_en": "\"switch/Select\" statements should end with \"default/Case Else\" clauses"},{"role_title": "控制流程语句“if”，“switch”，“for”，“foreach”，“while”，“do”和“try”不能嵌套太深.", "role_desc_en": "Nested if, switch, for, foreach, while, do, and try statements are key ingredients for making what's known as \"Spaghetti code\".\nSuch code is hard to read, refactor and therefore maintain.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (condition1) // Compliant - depth = 1\n{                  \n  /* ... */\n  if (condition2) // Compliant - depth = 2\n  {                \n    /* ... */\n    for(int i = 0; i &lt; 10; i++) // Compliant - depth = 3, not exceeding the limit\n    {  \n      /* ... */\n      if (condition4) // Noncompliant - depth = 4\n      {            \n        if (condition5) // Depth = 5, exceeding the limit, but issues are only reported on depth = 4\n        {          \n          /* ... */\n        }\n        return;\n      }\n    }\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-134", "role_id": "S134", "role_desc": "嵌套if，switch，for，foreach，while，do和try语句是制作所谓的“意粉代码”的关键因素.这样的代码很难阅读，重构并因此维护.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "CRITICAL", "role_title_en": "Control flow statements \"if\", \"switch\", \"for\", \"foreach\", \"while\", \"do\"  and \"try\" should not be nested too deeply"},{"role_title": "方法和属性不应太复杂.", "role_desc_en": "The cyclomatic complexity of methods and properties should not exceed a defined threshold. Complex code can perform poorly and will in any case be difficult to understand and therefore to maintain.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-1541", "role_id": "S1541", "role_desc": "方法和性质的循环复杂度不应超过定义的阈值.复杂的代码可以表现不佳，在任何情况下都难以理解，因此需要维护.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "CRITICAL", "role_title_en": "Methods and properties should not be too complex"},{"role_title": "类应该从类自己的“Dispose”方法中“处理”成员.", "role_desc_en": "It is possible in an IDisposable to call Dispose on class members from any method, but the contract of Dispose is that it will clean up all unmanaged resources. Move disposing of members to some other method, and you risk resource leaks.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class ResourceHolder : IDisposable\n{\n  private FileStream fs;  \n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open);\n  }\n  public void CloseResource()\n  {\n    this.fs.Close();\n  }\n\n  public void CleanUp() \n  {\n    this.fs.Dispose(); // Noncompliant; Dispose not called in class' Dispose method\n  }\n\n  public void Dispose() \n  {\n    // method added to satisfy demands of interface\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2952", "role_id": "S2952", "role_desc": "在IDisposable中可以从任何方法调用Dispose到Class成员，但Dispose的合同是它将清理所有非托管资源.将成员处理移到某种其他方法，并且可能会导致资源泄漏.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class ResourceHolder : IDisposable\n{\n  private FileStream fs;\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open);\n  }\n  public void CloseResource()\n  {\n    this.fs.Close();\n  }\n\n  public void Dispose() \n  {\n    this.fs.Dispose();\n  }\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Classes should \"Dispose\" of members from the classes' own \"Dispose\" methods"},{"role_title": "线路应通过单元测试具有足够的覆盖.", "role_desc_en": "An issue is created on a file as soon as the line coverage on this file is less than the required threshold. It gives the number of lines to be covered in order to reach the required threshold.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-1483", "role_id": "S1483", "role_desc": "一旦该文件的线路覆盖率小于所需阈值，就会在文件上创建一个问题.它给出要覆盖的行数以达到所需的阈值.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Lines should have sufficient coverage by unit tests"},{"role_title": "类型和“this”不应该用于锁定.", "role_desc_en": "Locking on the current object instance (i.e. this), or on a Type object increases the chance of deadlocks because any other thread could acquire (or attempt to acquire) the same lock for another unrelated purpose. Instead, a new, private object should be created and used for the lock.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic void MyLockingMethod()\n{\n  lock (this) // Noncompliant\n  {\n    // ...\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2551", "role_id": "S2551", "role_desc": "锁定当前对象实例（i.这个）或者一个Type对象增加了死锁的机会，因为任何其他线程可以获得（或尝试获取）另一个不相关目的的锁.相反，应该创建一个新的私有对象并将其用于锁定.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nobject lockObj = new object();\n\npublic void MyLockingMethod()\n{\n  lock (lockObj)\n  {\n    // ...\n  }\n}\n\n", "role_level": "CRITICAL", "role_title_en": "Types and \"this\" should not be used for locking"},{"role_title": "“部件.GetExecutingAssembly“不应该被调用.", "role_desc_en": "Using Type.Assembly to get the current assembly is nearly free in terms of performance; it's a simple property access. On the other hand, Assembly.GetExecutingAssembly() can take up to 30 times as long because it walks up the call stack to find the assembly.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Example\n{\n   public static void Main()\n   {\n      Assembly assem = Assembly.GetExecutingAssembly(); // Noncompliant\n      Console.WriteLine(\"Assembly name: {0}\", assem.FullName);\n   }\n}\n\n", "role_origin_id": "rule_RSPEC-3902", "role_id": "S3902", "role_desc": "使用类型.获得当前装配的装配在性能方面几乎是免费的;.另一方面，大会.GetExecutingAssembly（）最多可能需要30次，因为它会调用调用堆栈来查找程序集.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Example\n{\n   public static void Main()\n   {\n      Assembly assem = typeof(Example).Assembly; // Here we use the type of the current class\n      Console.WriteLine(\"Assembly name: {0}\", assem.FullName);\n   }\n}\n\n", "role_level": "MAJOR", "role_title_en": "\"Assembly.GetExecutingAssembly\" should not be called"},{"role_title": "字段应该是私有的.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Foo\n{\n  public int MagicNumber = 42; \n}\n\n", "role_origin_id": "rule_RSPEC-2357", "role_id": "S2357", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Foo\n{\n  public int MagicNumber \n  { \n    get { return 42; }\n  }\n}\n\n", "role_level": "MAJOR", "role_title_en": "Fields should be private"},{"role_title": "应使用短路逻辑来防止条件中的空指针取消引用.", "role_desc_en": "", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-1697", "role_id": "S1697", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif (str == null || str.Length == 0)\n{\n  Console.WriteLine(\"String is empty\");\n}\n\nif (str != null &amp;&amp; str.Length &gt; 0)\n{\n  Console.WriteLine(\"String is not empty\");\n}\n\n", "role_level": "MAJOR", "role_title_en": "Short-circuit logic should be used to prevent null pointer dereferences in conditionals"},{"role_title": "IP地址不应该被硬编码.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvar ip = \"127.0.0.1\";\nvar address = IPAddress.Parse(ip);\n\n", "role_origin_id": "rule_RSPEC-1313", "role_id": "S1313", "role_desc": "", "role_type": "Vulnerability", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvar ip = ConfigurationManager.AppSettings[\"myapplication.ip\"];\nvar address = IPAddress.Parse(ip);\n\n", "role_level": "MAJOR", "role_title_en": "IP addresses should not be hardcoded"},{"role_title": "不应对浮点数进行相等测试.", "role_desc_en": "Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is not associative; push a float or a double through a series of simple mathematical operations and the answer will be different based on the order of those operation because of the rounding that takes place at each step.Even simple floating point assignments are not simple:(Results will vary based on compiler and compiler settings)Therefore, the use of the equality (==) and inequality (!=) operators on float or double values is almost always an error.This rule checks for the use of direct and indirect equality/inequailty tests on floats and doubles.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nfloat myNumber = 3.146f;\nif ( myNumber == 3.146f ) //Noncompliant. Because of floating point imprecision, this will be false\n{\n  // ...\n}\n\nif (myNumber &lt;= 3.146f &amp;&amp; mNumber &gt;= 3.146f) // Noncompliant indirect equality test\n{\n  // ...\n}\n\nif (myNumber &lt; 4 || myNumber &gt; 4) // Noncompliant indirect inequality test\n{\n  // ...\n}\n\n", "role_origin_id": "rule_RSPEC-1244", "role_id": "S1244", "role_desc": "浮点数学是不精确的，因为在二进制表示中存储这些值的挑战.更糟糕的是，浮点数学不是联想的;.即使简单的浮点分配也不简单：.（结果将根据编译器和编译器设置而有所不同）.因此，对float或double值使用等号（==）和不等式（！=）运算符几乎总是一个错误.该规则检查对浮动和双打的直接和间接平等/不等式测试的使用.", "role_type": "Bug", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Floating point numbers should not be tested for equality"},{"role_title": "无用“if（true）{.}“和”if（false）{.}“块应该被删除.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (true) \n{  \n  DoSomething(); \n}\n...\nif (false) \n{\n  DoSomethingElse(); \n}\n\nif (2 &lt; 3 ) { ... }  // Noncompliant; always false\n\nint i = 0;\nint j = 0;\n// ...\nj = Foo();\n\nif (j &gt; 0 &amp;&amp; i &gt; 0) { ... }  // Noncompliant; always false - i never set after initialization\n\nbool b = true;\n//...\nif (b || !b) { ... }  // Noncompliant\n\n", "role_origin_id": "rule_RSPEC-1145", "role_id": "S1145", "role_desc": "", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nDoSomething(); \n...\n\n", "role_level": "MAJOR", "role_title_en": "Useless \"if(true) {...}\" and \"if(false){...}\" blocks should be removed"},{"role_title": "“对于”循环停止条件应该是不变的.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass Foo \n{\n    static void Main() \n    {\n        for (int i = 1; i &lt;= 5; i++) \n        {\n            Console.WriteLine(i);\n            if (condition) \n            {\n               i = 20;\n           }\n        }\n    }\n}\n\n", "role_origin_id": "rule_RSPEC-127", "role_id": "S127", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass Foo \n{\n    static void Main() \n    {\n        for (int i = 1; i &lt;= 5; i++) \n        {\n            Console.WriteLine(i);\n        }\n    }\n}\n\n", "role_level": "MAJOR", "role_title_en": "\"for\" loop stop conditions should be invariant"},