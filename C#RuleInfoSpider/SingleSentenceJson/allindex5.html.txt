{"role_title": "声明应该分开.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif(someCondition) DoSomething();\n\n", "role_origin_id": "rule_RSPEC-122", "role_id": "S122", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif(someCondition) \n{\n  DoSomething();\n}\n\n", "role_level": "MAJOR", "role_title_en": "Statements should be on separate lines"},{"role_title": "线条不应该太长.", "role_desc_en": "Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-103", "role_id": "S103", "role_desc": "必须水平滚动才能更快速地了解任何代码.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Lines should not be too long"},{"role_title": "文件不应该有太多的代码行.", "role_desc_en": "A source file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain. Above a specific threshold, it is strongly advised to refactor it into smaller pieces of code which focus on well defined tasks. Those smaller files will not only be easier to understand but also probably easier to test.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-104", "role_id": "S104", "role_desc": "增长太多的源文件往往会累积太多的责任，并且不可避免地变得难以理解，因此需要维护.高于特定的阈值，强烈建议将其重构为较小的代码，重点在明确的任务上.那些较小的文件不仅容易理解，而且可能更容易测试.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Files should not have too many lines of code"},{"role_title": "终结者不应该是空的.", "role_desc_en": "Finalizers come with a performance cost due to the overhead of tracking the life cycle of objects. An empty one is consequently costly with no benefit or justification.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Foo \n{\n    ~Foo() // Noncompliant\n    { \n    }\n}\n\n", "role_origin_id": "rule_RSPEC-3880", "role_id": "S3880", "role_desc": "由于跟踪对象生命周期的开销，终结者具有性能成本.因此，空的一个是昂贵的，没有任何好处或理由.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Finalizers should not be empty"},{"role_title": "值类型应实现“IEquatable \\u003cT\\u003e”.", "role_desc_en": "If you're using a struct, it is likely because you're interested in performance. But by failing to implement IEquatable&lt;T&gt; you're loosing performance when comparisons are made because without IEquatable&lt;T&gt;, boxing and reflection are used to make comparisons. ", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nstruct MyStruct  // Noncompliant\n{\n  private int i;\n  public int I\n  {\n    //...\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3898", "role_id": "S3898", "role_desc": "如果您使用的是结构体，那么可能是因为您对性能感兴趣.但是由于未能实现IEquatable＆lt; T＆gt;.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MAJOR", "role_title_en": "Value types should implement \"IEquatable<T>\""},{"role_title": "“GC.对于没有析构函数的类型，不应该调用“SuppressFinalize”.", "role_desc_en": "GC.SuppressFinalize asks the Common Language Runtime not to call the finalizer of an object. This is useful when implementing the dispose pattern where object finalization is already handled in IDisposable.Dispose. However, it has no effect if there is no finalizer defined in the object's type, so using it in such cases is just confusing.This rule raises an issue when GC.SuppressFinalize is called for objects of sealed types without a finalizer.*Note:* S3971 is a stricter version of this rule. Typically it makes sense to activate only one of these 2 rules.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nsealed class MyClass\n{\n  public void Method()\n  {\n    ...\n    GC.SuppressFinalize(this); //Noncompliant\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3234", "role_id": "S3234", "role_desc": "GC.SuppressFinalize要求公共语言运行时不调用对象的终结器.这在实现在IDisposable中已处理对象终结的处理模式时非常有用.部署.但是，如果没有在对象的类型中定义finalizer，那么它就没有任何效果，所以在这种情况下使用它只是混乱.这个规则引发了GC问题.SuppressFinalize被称为没有终结器的密封类型的对象.*注意：* S3971是这个规则的更严格的版本.通常，仅激活这两个规则之一是有意义的.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nsealed class MyClass\n{\n  public void Method()\n  {\n    ...\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "\"GC.SuppressFinalize\" should not be invoked for types without destructors"},{"role_title": "“static readonly”常量应该是“const”.", "role_desc_en": "The value of a static readonly field is computed at runtime while the value of a const field is calculated at compile time, which improves performance.This rule raises an issue when a static readonly field is initialiazed with a value that is computable at compile time.As specified by Microsoft, the list of types that can have a constant value are:", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nnamespace myLib\n{\n  public class Foo\n  {\n    static readonly int x = 1;  // Noncompliant\n    static readonly int y = x + 4; // Noncompliant\n    static readonly string s = \"Bar\";  // Noncompliant\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3962", "role_id": "S3962", "role_desc": "在运行时计算静态可读字段的值，而在编译时计算const字段的值，从而提高性能.当静态只读字段使用可编译时可计算的值初始化时，此规则引发了一个问题.如Microsoft所指定的，可以具有常量值的类型列表有：.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nnamespace myLib\n{\n  public class Foo\n  {\n    const int x = 1;\n    const int y = x + 4;\n    const string s = \"Bar\";\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "\"static readonly\" constants should be \"const\" instead"},{"role_title": "“静态”字段应该被内联初始化.", "role_desc_en": "When a static constructor serves no other purpose that initializing static fields, it comes with an unnecessary performance cost because the compiler generates a check before each static method or instance constructor invocation.Instead, inline initialization is highly recommended.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nnamespace myLib\n{\n  public class Foo\n  {\n    static int i;\n    static string s;\n\n    static Foo() // Noncompliant\n    {\n      i = 3;\n      ResourceManager sm =  new ResourceManager(\"strings\", Assembly.GetExecutingAssembly());\n      s = sm.GetString(\"mystring\");\n    }\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3963", "role_id": "S3963", "role_desc": "当静态构造函数没有其他用于初始化静态字段的目的时，它会带来不必要的性能成本，因为编译器会在每个静态方法或实例构造函数调用之前生成检查.相反，强烈建议使用内联初始化.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nnamespace myLib\n{\n  public class Foo\n  {\n    static int i =3;\n    static string s = InitString();\n\n    static string InitString()\n    {\n      ResourceManager sm = new ResourceManager(\"strings\", Assembly.GetExecutingAssembly());\n      return sm.GetString(\"mystring\");\n    }\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "\"static\" fields should be initialized inline"},{"role_title": "顺序测试不应该检查相同的条件.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif (a == b)\n{\n  doTheThing(b);\n}\nif (a == b) // Noncompliant; is this really what was intended?\n{\n  doTheThing(c);\n}\n\n", "role_origin_id": "rule_RSPEC-2760", "role_id": "S2760", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif (a == b)\n{\n  doTheThing(b);\n  doTheThing(c);\n}\n\n", "role_level": "MINOR", "role_title_en": "Sequential tests should not check the same condition"},{"role_title": "不应使用冗余修饰符.", "role_desc_en": "Unnecessary keywords simply clutter the code and should be removed. Specifically:", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic partial class MyClass // Noncompliant\n{\n  public virtual void Method()\n  {\n  }\n}\n\npublic sealed class MyOtherClass : MyClass\n{\n  public sealed override void Method() // Noncompliant\n  {\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2333", "role_id": "S2333", "role_desc": "不必要的关键字简单地混淆了代码，应该被删除.特别：.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class MyClass\n{\n  public virtual void Method()\n  {\n  }\n}\n\npublic sealed class MyOtherClass : MyClass\n{\n  public override void Method()\n  {\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Redundant modifiers should not be used"},{"role_title": "不应使用控制台日志记录.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nprivate void DoSomething ()\n{\n  // ...\n  Console.WriteLine (\"so far, so good...\"); // Noncompliant\n  // ...\n}\n\n", "role_origin_id": "rule_RSPEC-2228", "role_id": "S2228", "role_desc": "", "role_type": "Vulnerability", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Console logging should not be used"},{"role_title": "抽象类应该有抽象和具体的方法.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic abstract class Animal //Noncompliant; should be an interface\n{\n  abstract void Move();\n  abstract void Feed();\n}\n\npublic abstract class Color //Noncompliant; should be concrete with a private constructor\n{\n  private int red = 0;\n  private int green = 0;\n  private int blue = 0;\n\n  public int GetRed()\n  {\n    return red;\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-1694", "role_id": "S1694", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic interface Animal\n{\n  void Move();\n  void Feed();\n}\n\npublic class Color\n{\n  private int red = 0;\n  private int green = 0;\n  private int blue = 0;\n\n  private Color()\n  {}\n\n  public int GetRed()\n  {\n    return red;\n  }\n}\n\npublic abstract class Lamp\n{\n  private bool switchLamp = false;\n\n  public abstract void Glow();\n\n  public void FlipSwitch()\n  {\n    switchLamp = !switchLamp;\n    if (switchLamp)\n    {\n      Glow();\n    }\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "An abstract class should have both abstract and concrete methods"},{"role_title": "多个变量不应在同一行上声明.", "role_desc_en": "Declaring multiple variable on one line is difficult to read.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass MyClass \n{\n  private int a, b; // Noncompliant\n\n  public void Method()\n  {\n    int c, d; // Noncompliant\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-1659", "role_id": "S1659", "role_desc": "在一行上声明多个变量很难阅读.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass MyClass \n{\n  private int a;\n  private int b;\n\n  public void Method()\n  {\n    int c;\n    int d;\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Multiple variables should not be declared on the same line"},{"role_title": "“switch”语句应该至少有3个“case”子句.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nswitch (variable)\n{\n  case 0:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n\n", "role_origin_id": "rule_RSPEC-1301", "role_id": "S1301", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif (variable == 0)\n{\n  doSomething();\n}\nelse\n{\n  doSomethingElse();\n}\n\n", "role_level": "MINOR", "role_title_en": "\"switch\" statements should have at least 3 \"case\" clauses"},{"role_title": "除了switch开关外，不应该使用break语句.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nint i = 0;\nwhile (true)\n{\n  if (i == 10)\n  {\n    break;      // Non-Compliant\n  }\n\n  Console.WriteLine(i);\n  i++;\n}\n\n", "role_origin_id": "rule_RSPEC-1227", "role_id": "S1227", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nint i = 0;\nwhile (i != 10) // Compliant\n{\n  Console.WriteLine(i);\n  i++;\n}\n\n", "role_level": "MINOR", "role_title_en": "break statements should not be used except for switch cases"},{"role_title": "一条紧密的大括号应位于一行的开头.", "role_desc_en": "", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nif(condition) \n{\n  doSomething();} \n\n", "role_origin_id": "rule_RSPEC-1109", "role_id": "S1109", "role_desc": "", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nif(condition) \n{\n  doSomething();\n} \n\n", "role_level": "MINOR", "role_title_en": "A close curly brace should be located at the beginning of a line"},{"role_title": "当“等于”被覆盖时，不应使用“==”.", "role_desc_en": "Using the equality == and inequality != operators to compare two objects generally works. The operators can be overloaded, and therefore the comparison can resolve to the appropriate method. However, when the operators are used on interface instances, then == resolves to reference equality, which may result in unexpected behavior if implementing classes override Equals. Similarly, when a class overrides Equals, but instances are compared with non-overloaded ==, there is a high chance that value comparison was meant instead of the reference one.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic interface IMyInterface\n{\n}\n\npublic class MyClass : IMyInterface\n{\n    public override bool Equals(object obj)\n    {\n        //...\n    }\n}\n\npublic class Program\n{\n    public static void Method(IMyInterface instance1, IMyInterface instance2)\n    {\n        if (instance1 == instance2) // Noncompliant, will do reference equality check, but was that intended? MyClass overrides Equals.\n        {\n            Console.WriteLine(\"Equal\");\n        }\n    }\n}\n\n", "role_origin_id": "rule_RSPEC-1698", "role_id": "S1698", "role_desc": "使用等于==和不等式！=运算符比较两个对象通常有效.操作员可以过载，因此比较可以解决适当的方法.但是，当接口实例使用运算符时，==解析为引用相等性，如果实现类覆盖等于.类似地，当一个类覆盖Equals，但是实例与非重载的==比较时，有很大的可能性，而不是参考值.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic interface IMyInterface\n{\n}\n\npublic class MyClass : IMyInterface\n{\n    public override bool Equals(object obj)\n    {\n        //...\n    }\n}\n\npublic class Program\n{\n    public static void Method(IMyInterface instance1, IMyInterface instance2)\n    {\n        if (object.Equals(instance1, instance2)) // object.Equals checks for null and then calls the instance based Equals, so MyClass.Equals\n        {\n            Console.WriteLine(\"Equal\");\n        }\n    }\n}\n\n", "role_level": "MINOR", "role_title_en": "\"==\" should not be used when \"Equals\" is overridden"},{"role_title": "不应将成员初始化为默认值.", "role_desc_en": "The compiler automatically initializes class fields, auto-properties and events to their default values before setting them with any initialization values, so there is no need to explicitly set a member to its default value. Further, under the logic that cleaner code is better code, it's considered poor style to do so.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass X\n{\n  public int field = 0; // Noncompliant\n  public object o = null; // Noncompliant\n  public object MyProperty { get; set; } = null; // Noncompliant\n  public event EventHandler MyEvent = null;  // Noncompliant\n}\n\n", "role_origin_id": "rule_RSPEC-3052", "role_id": "S3052", "role_desc": "编译器会自动将类字段，自动属性和事件初始化为默认值，然后再使用任何初始化值进行设置，因此无需将成员显式设置为其默认值.此外，根据清洁代码是更好的代码，这被认为是糟糕的风格.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass X\n{\n  public int field;\n  public object o;\n  public object MyProperty { get; set; }\n  public event EventHandler MyEvent;\n}\n\n", "role_level": "MINOR", "role_title_en": "Members should not be initialized to default values"},{"role_title": "方法参数和捕获的异常不应重新分配.", "role_desc_en": "While it is technically correct to assign to parameters from within method bodies, it is better to use temporary variables to store intermediate results.\nThis rule will typically detect cases where a constructor parameter is assigned to itself instead of a field of the same name, i.e. when this was forgotten.\nAllowing parameters to be assigned to also reduces the code readability as developers will not be able to know whether the original parameter or some temporary variable is being accessed without going through the whole method.\nMoreover, some developers might also expect assignments of method parameters to be visible from callers, which is not the case and can confuse them.\nAll parameters should be treated as readonly.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass MyClass\n{\n  public string name;\n\n  public MyClass(string name)\n  {\n    name = name;                    // Noncompliant - useless identity assignment\n  }\n\n  public int Add(int a, int b)\n  {\n    a = a + b;                      // Noncompliant\n\n    /* additional logic */\n\n    return a;                       // Seems like the parameter is returned as is, what is the point?\n  }\n\n  public static void Main()\n  {\n    MyClass foo = new MyClass();\n    int a = 40;\n    int b = 2;\n    foo.Add(a, b);                  // Variable \"a\" will still hold 40 after this call\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-1226", "role_id": "S1226", "role_desc": "从方法体内分配参数在技术上是正确的，最好使用临时变量来存储中间结果.该规则通常会检测到构造函数参数分配给自身而不是同名的字段的情况，i.当这被遗忘的时候.允许分配参数还可以降低代码可读性，因为开发人员将无法知道是否正在访问原始参数或某个临时变量，而无需通过整个方法.此外，一些开发人员还可能期望方法参数的分配从调用者可见，但情况并非如此，可能会使它们混淆.所有参数应视为只读.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass MyClass\n{\n  public string name;\n\n  public MyClass(string name)\n  {\n    this.name = name;               // Compliant\n  }\n\n  public int Add(int a, int b)\n  {\n    return a + b;                   // Compliant\n  }\n\n  public static void Main()\n  {\n    MyClass foo = new MyClass();\n    int a = 40;\n    int b = 2;\n    foo.Add(a, b);\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Method parameters and caught exceptions should not be reassigned"},{"role_title": "应该检查从流读取返回的长度.", "role_desc_en": "You cannot assume that any given stream reading call will fill the byte[] passed in to the method with the number of bytes requested. Instead, you must check the value returned by the read method to see how many bytes were read. Fail to do so, and you introduce a bug that is both harmful and difficult to reproduce.This rule raises an issue when a Stream.Read or a Stream.ReadAsync method is called, but the return value is not checked.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic void DoSomething(string fileName) \n{\n  using (var stream = File.Open(fileName, FileMode.Open))\n  {\n    var result = new byte[stream.Length];\n    stream.Read(result, 0, (int)stream.Length); // Noncompliant\n    // ... do something with result\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2674", "role_id": "S2674", "role_desc": "您不能假定任何给定的流读取调用将填充传递给方法的字节[]，请求的字节数.相反，您必须检查读取方法返回的值以查看读取的字节数.没有这样做，你会引入一个既有害又难以复制的错误.这个规则引起了一个Stream的问题.读或流.调用ReadAsync方法，但不检查返回值.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic void DoSomething(string fileName) \n{\n  using (var stream = File.Open(fileName, FileMode.Open))\n  {\n    var buffer = new byte[1024];\n    using (var ms = new MemoryStream())\n    {\n        int read;\n        while ((read = stream.Read(buffer, 0, buffer.Length)) &gt; 0)\n        {\n            ms.Write(buffer, 0, read);\n        }\n        // ... do something with ms\n    }    \n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "The length returned from a stream read should be checked"},{"role_title": "“ToString（）”调用不应该是多余的.", "role_desc_en": "Invoking a method designed to return a string representation of an object which is already a string is a waste of keystrokes. Similarly, explicitly invoking ToString() when the compiler would do it implicitly is also needless code-bloat.This rule raises an issue when ToString() is invoked:", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvar s = \"foo\";\nvar t = \"fee fie foe \" + s.ToString();  // Noncompliant\nvar someObject = new object();\nvar u = \"\" + someObject.ToString(); // Noncompliant\nvar v = string.Format(\"{0}\", someObject.ToString()); // Noncompliant\n\n", "role_origin_id": "rule_RSPEC-1858", "role_id": "S1858", "role_desc": "调用一个设计为返回已经是字符串的对象的字符串表示形式的方法是浪费敲击.类似地，当编译器会隐式地调用ToString（）也是不必要的代码膨胀.当调用ToString（）时，此规则引发了一个问题：.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvar s = \"foo\";\nvar t = \"fee fie foe \" + s;\nvar someObject = new object();\nvar u = \"\" + someObject;\nvar v = string.Format(\"{0}\", someObject);\n\n", "role_level": "MINOR", "role_title_en": "\"ToString()\" calls should not be redundant"},{"role_title": "“密封”班不应该有“保护”的成员.", "role_desc_en": "The difference between private and protected visibility is that child classes can see and use protected members, but they cannot see private ones. Since a sealed class cannot have children, marking its members protected is confusingly pointless.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic sealed class MySealedClass \n{\n    protected string name = \"Fred\";  // Noncompliant\n    protected void SetName(string name) // Noncompliant\n    {\n        // ...\n    }\n}\n\n", "role_origin_id": "rule_RSPEC-2156", "role_id": "S2156", "role_desc": "私有和受保护的可见性之间的区别是，子类可以看到并使用受保护的成员，但是它们看不到私有的成员.由于密封的班级不能有孩子，所以保护他们的成员是令人难以置信的.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic sealed class MySealedClass \n{\n    private string name = \"Fred\";\n    public void SetName(string name)\n    {\n        // ...\n    }\n}\n\n", "role_level": "MINOR", "role_title_en": "\"sealed\" classes should not have \"protected\" members"},{"role_title": "应为“字符串”操作指定文化.", "role_desc_en": "string.ToLower(), ToUpper, IndexOf, LastIndexOf, and Compare are all culture-dependent, as are some (floating point number and DateTime-related) calls to ToString. Fortunately, all have variants which accept an argument specifying the culture or formatter to use. Leave that argument off and the call will use the system default culture, possibly creating problems with international characters.string.CompareTo() is also culture specific, but has no overload that takes a culture information, so instead it's better to use CompareOrdinal, or Compare with culture.Calls without a culture may work fine in the system's \"home\" environment, but break in ways that are extremely difficult to diagnose for customers who use different encodings. Such bugs can be nearly, if not completely, impossible to reproduce when it's time to fix them.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvar lowered = someString.ToLower(); //Noncompliant\n\n", "role_origin_id": "rule_RSPEC-1449", "role_id": "S1449", "role_desc": "串.ToLower（），ToUpper，IndexOf，LastIndexOf和Compare都是文化依赖的，ToString的一些（浮点数和DateTime相关）调用.幸运的是，所有的变体都接受一个参数，指定要使用的文化或格式化器.离开该参数，调用将使用系统默认文化，可能会产生国际字符的问题.串.CompareTo（）也是文化特定的，但没有重载的文化信息，所以反而更好的是使用CompareOrdinal或与文化比较.没有文化的电话可能会在系统的“家庭”环境中正常工作，但是对于使用不同编码的客户来说，极其难以诊断的方式是破坏的.这样的错误可能几乎，如果不是完全不可能复制，当它是时候解决它们.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvar lowered = someString.ToLower(CultureInfo.InvariantCulture);\n\n", "role_level": "MINOR", "role_title_en": "Culture should be specified for \"string\" operations"},{"role_title": "方法和属性应在骆驼案中命名.", "role_desc_en": "Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not method and property names are camel cased. To reduce noise, two consecutive upper case characters are allowed unless they form the whole name. So, MyXMethod is compliant, but XM on its own is not.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic int doSomething(){...}\n\n", "role_origin_id": "rule_RSPEC-100", "role_id": "S100", "role_desc": "共享命名约定允许团队有效协作.此规则检查方法和属性名称是否为骆驼套装.为了减少噪音，除非形成整个名称，否则允许连续使用两个大写字母.所以，MyXMethod是兼容的，但XM自己不是.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic int DoSomething(){...}\n\n", "role_level": "MINOR", "role_title_en": "Methods and properties should be named in camel case"},{"role_title": "构造函数和析构函数声明不应该是多余的.", "role_desc_en": "Since the compiler will automatically invoke the base type's no-argument constructor, there's no need to specify its invocation explicitly. Also, when only a single public parameterless constructor is defined in a class, then that constructor can be removed because the compiler would generate it automatically. Similarly, empty static constructors and empty destructors are also wasted keystrokes.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nclass X\n{\n  public X() { } // Noncompliant\n  static X() { }  // Noncompliant\n  ~X() { } // Noncompliant\n\n  ...\n}\n\nclass Y : X\n{\n  public Y(int parameter) : base() // Noncompliant\n  {\n    /* does something with the parameter */\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3253", "role_id": "S3253", "role_desc": "由于编译器将自动调用基类型无参构造函数，所以不需要明确指定它的调用.而且，当一个类中只定义了一个公共无参数的构造函数时，该构造函数可以被删除，因为编译器会自动生成.类似地，空的静态构造函数和空的析构函数也是浪费的击键.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nclass X\n{\n  ...\n}\n\nclass Y : X\n{\n  public Y(int parameter)\n  {\n    /* does something with the parameter */\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Constructor and destructor declarations should not be redundant"},{"role_title": "声明和初始化应尽可能简洁.", "role_desc_en": "Unnecessarily verbose declarations and initializations make it harder to read the code, and should be simplified.Specifically the following should be omitted when they can be inferred:", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvar l = new List&lt;int&gt;() {}; // Noncompliant, {} can be removed\nvar o = new object() {}; // Noncompliant, {} can be removed\n\nvar ints = new int[] {1, 2, 3}; // Noncompliant, int can be omitted\nints = new int[3] {1, 2, 3}; // Noncompliant, the size specification can be removed\n\nint? i = new int?(5); // Noncompliant new int? could be omitted, it can be inferred from the declaration, and there's implicit conversion from T to T?\nvar j = new int?(5); \n\nFunc&lt;int, int&gt; f1 = (int i) =&gt; 1; //Noncompliant, can be simplified\n\nclass Class\n{\n    private event EventHandler MyEvent;\n\n    public Class()\n    {\n        MyEvent += new EventHandler((a,b)=&gt;{ }); // Noncompliant, needlessly verbose\n    }\n}\n\n", "role_origin_id": "rule_RSPEC-3257", "role_id": "S3257", "role_desc": "不必要的详细的声明和初始化使得读取代码变得更加困难，应该被简化.具体来说，可以推断出以下内容：.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvar l = new List&lt;int&gt;();\nvar o = new object();\n\nvar ints = new [] {1, 2, 3};\nints = new [] {1, 2, 3};\n\nint? i = 5;\nvar j = new int?(5); \n\nFunc&lt;int, int&gt; f1 = (i) =&gt; 1;\n\nclass Class\n{\n    private event EventHandler MyEvent;\n\n    public Class()\n    {\n        MyEvent += (a,b)=&gt;{ };\n    }\n}\n\n", "role_level": "MINOR", "role_title_en": "Declarations and initializations should be as concise as possible"},{"role_title": "默认参数值不应作为参数传递.", "role_desc_en": "Specifying the default parameter values in a method call is redundant. Such values should be omitted in the interests of readability.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic void M(int x, int y=5, int z = 7) { /* ... */ }\n\n// ...\nM(1, 5); //Noncompliant, y has the default value\nM(1, z: 7); //Noncompliant, z has the default value\n\n", "role_origin_id": "rule_RSPEC-3254", "role_id": "S3254", "role_desc": "在方法调用中指定默认参数值是多余的.为了可读性，应该省略这些值.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic void M(int x, int y=5, int z = 7) { /* ... */ }\n\n// ...\nM(1);\nM(1);\n\n", "role_level": "MINOR", "role_title_en": "Default parameter values should not be passed as arguments"},{"role_title": "应该删除空的“默认”子句.", "role_desc_en": "The default clause should take appropriate action. Having an empty default is a waste of keystrokes.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nenum Fruit\n{\n  Apple,\n  Orange,\n  Banana\n}\n\nvoid PrintName(Fruit fruit)\n{\n  switch(fruit)\n  {\n    case Fruit.Apple:\n      Console.WriteLine(\"apple\");\n      break;\n    default:  //Noncompliant\n      break;\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3532", "role_id": "S3532", "role_desc": "默认子句应该采取适当的措施.空的默认是浪费击键.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nenum Fruit\n{\n  Apple,\n  Orange,\n  Banana\n}\n\nvoid PrintName(Fruit fruit)\n{\n  switch(fruit)\n  {\n    case Fruit.Apple:\n      Console.WriteLine(\"apple\");\n      break;\n    default:\n      throw new NotSupportedException();\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Empty \"default\" clauses should be removed"},{"role_title": "不限于引用类型的通用参数不应与“null”进行比较.", "role_desc_en": "When constraints have not been applied to restrict a generic type parameter to be a reference type, then a value type, such as a struct, could also be passed. In such cases, comparing the type parameter to null would always be false, because a struct can be empty, but never null. If a value type is truly what's expected, then the comparison should use default(). If it's not, then constraints should be added so that no value type can be passed.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nprivate bool IsDefault&lt;T&gt;(T value) \n{\n  if (value == null) // Noncompliant\n  {\n    // ...\n  }\n  // ...\n}\n\n", "role_origin_id": "rule_RSPEC-2955", "role_id": "S2955", "role_desc": "当约束没有被应用以将泛型类型参数限制为引用类型时，也可以传递值类型（如struct）.在这种情况下，将type参数与null进行比较始终为false，因为struct可以为空，但不能为空.如果值类型是真正的预期，那么比较应该使用default（）.如果不是，则应添加约束，以便不能传递值类型.", "role_type": "Bug", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nprivate bool IsDefault&lt;T&gt;(T value) \n{\n  if(object.Equals(value, default(T)))\n  {\n    // ...\n  }\n  // ...\n}\n\n", "role_level": "MINOR", "role_title_en": "Generic parameters not constrained to reference types should not be compared to \"null\""},{"role_title": "不访问实例数据的方法和属性应该是静态的.", "role_desc_en": "Class methods and properties that don't access instance data can be static to prevent any misunderstanding about the contract of the method. ", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic class Utilities\n{\n  public int MagicNum // Noncompliant\n  {\n    get \n    {\n      return 42;\n    }\n  }\n\n  private static string magicWord = \"please\";\n  public string MagicWord  // Noncompliant\n  {\n    get \n    {\n      return magicWord;\n    }\n    set \n    {\n      magicWord = value;\n    }\n  }\n\n  public int Sum(int a, int b)  // Noncompliant\n  {\n    return a + b;\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-2325", "role_id": "S2325", "role_desc": "不访问实例数据的类方法和属性可以是静态的，以防止对方法的合同的任何误解.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic class Utilities\n{\n  public static int MagicNum\n  {\n    get \n    {\n      return 42;\n    }\n  }\n\n  private static string magicWord = \"please\";\n  public static string MagicWord \n  {\n    get \n    {\n      return magicWord;\n    }\n    set \n    {\n      magicWord = value;\n    }\n  }\n\n  public static int Sum(int a, int b)\n  {\n    return a + b;\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Methods and properties that don't access instance data should be static"},{"role_title": "不应使用多维数组.", "role_desc_en": "A jagged array is an array whose elements are arrays. It is recommended over a multidimensional array because the arrays that make up the elements can be of different sizes, which avoids wasting memory space.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nint [,] myArray =  // Noncompliant\n    {\n        {1,2,3,4},\n        {5,6,7,0},\n        {8,0,0,0},\n        {9,0,0,0}\n    };\n// ...\nmyArray[1,1] = 0;\n\n", "role_origin_id": "rule_RSPEC-3967", "role_id": "S3967", "role_desc": "锯齿状阵列是一个数组，其元素是数组.建议使用多维数组，因为构成元素的数组可能有不同的大小，从而避免浪费内存空间.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nint[][] myArray = \n    { \n        new int[] {1,2,3,4},\n        new int[] {5,6,7},\n        new int[] {8},\n        new int[] {9}\n    };\n// ...\nmyArray[1][1] = 0;\n\n", "role_level": "MINOR", "role_title_en": "Multidimensional arrays should not be used"},{"role_title": "参数名称不应与其方法的名称重复.", "role_desc_en": "The name of a method should communicate what it does, and the names of its parameters should indicate how they're used. If a method and its parameter have the same name it is an indication that one of these rules of thumb has been broken, if not both. Even if by some trick of language that's not the case, it is still likely to confuse callers and maintainers.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic void Login(string login)  // Noncompliant\n{\n  //...\n}\n\n", "role_origin_id": "rule_RSPEC-3872", "role_id": "S3872", "role_desc": "方法的名称应该说明它的作用，其参数的名称应该说明它们的使用方式.如果一个方法和它的参数具有相同的名称，这表明这些经验法则之一已经被破坏，如果不是这两个.即使通过某种语言的伎俩不是这样，它仍然可能会混淆呼叫者和维护者.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\npublic void Login(string userName)\n{\n  //...\n}\n\n", "role_level": "MINOR", "role_title_en": "Parameter names should not duplicate the names of their methods"},{"role_title": "不应使用冗余括号.", "role_desc_en": "Redundant parentheses are simply wasted keystrokes, and should be removed.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\n[MyAttribute()] //Noncompliant\nclass MyClass\n{\n  public int MyProperty { get; set; }\n  public static MyClass CreateNew(int propertyValue)\n  {\n    return new MyClass() //Noncompliant\n    {\n      MyProperty = propertyValue\n    };\n  }\n}\n\n", "role_origin_id": "rule_RSPEC-3235", "role_id": "S3235", "role_desc": "冗余括号只是浪费了按键，应该被删除.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\n[MyAttribute] \nclass MyClass\n{\n  public int MyProperty { get; set; }\n  public static MyClass CreateNew(int propertyValue)\n  {\n    return new MyClass \n    {\n      MyProperty = propertyValue\n    };\n  }\n}\n\n", "role_level": "MINOR", "role_title_en": "Redundant parentheses should not be used"},{"role_title": "在匿名类中应省略冗余属性名称.", "role_desc_en": "When an anonymous type's properties are copied from properties or variables with the same names, it yields cleaner code to omit the new type's property name and the assignment operator.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nvar X = 5;\n\nvar anon = new \n{\n  X = X, //Noncompliant, the new object would have the same property without the \"X =\" part.\n  Y = \"my string\"\n};\n\n", "role_origin_id": "rule_RSPEC-3441", "role_id": "S3441", "role_desc": "当匿名类型的属性从具有相同名称的属性或变量复制时，它会生成更清晰的代码以省略新类型的属性名称和赋值运算符.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nvar X = 5;\n\nvar anon = new \n{\n  X,\n  Y = \"my string\"\n};\n\n", "role_level": "MINOR", "role_title_en": "Redundant property names should be omitted in anonymous classes"},{"role_title": "跳过的单元测试应该被移除或固定.", "role_desc_en": "Skipped unit tests are considered dead code. Either they should be activated again (and updated) or they should be removed.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-3424", "role_id": "S3424", "role_desc": "跳过的单元测试被认为是死码.或者它们应该被重新激活（并更新），或者应该被删除.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Skipped unit tests should be either removed or fixed"},{"role_title": "字符串或整数类型应用于索引器.", "role_desc_en": "Strings and integral types are typically used as indexers. When some other type is required, it typically indicates design problems, and potentially a situation where a method should be used instead.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\npublic int this[MyCustomClass index]  // Noncompliant\n{  \n    // get and set accessors  \n}\n\n", "role_origin_id": "rule_RSPEC-3876", "role_id": "S3876", "role_desc": "字符串和整数类型通常用作索引器.当需要其他类型时，通常会指出设计问题，并且可能会导致使用方法的情况.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Strings or integral types should be used for indexers"},{"role_title": "不应使用制表字符.", "role_desc_en": "Developers should not need to configure the tab width of their text editors in order to be able to read source code.\nSo the use of the tabulation character must be banned.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-105", "role_id": "S105", "role_desc": "开发人员不需要配置其文本编辑器的制表符宽度，以便能够读取源代码.所以使用制表字符必须被禁止.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Tabulation characters should not be used"},{"role_title": "应该使用最简单的可能条件语法.", "role_desc_en": "In the interests of keeping code clean, the simplest possible conditional syntax should be used. That means ", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\nobject a = null, b = null, x;\n\nif (a != null) // Noncompliant; needlessly verbose\n{\n  x = a;\n}\nelse\n{\n  x = b;\n}\n\nx = a != null ? a : b; // Noncompliant; better but could still be simplified\n\nx = (a == null) ? new object() : a; // Noncompliant\n\nif (condition) // Noncompliant\n{\n  x = a;\n}\nelse\n{\n  x = b;\n}\n\nvar y = null ?? new object(); // Noncompliant\n\n", "role_origin_id": "rule_RSPEC-3240", "role_id": "S3240", "role_desc": "为了保持代码清洁，应该使用最简单的条件语法.这意味着.", "role_type": "CodeSmell", "role_have_compliant_code": "Y", "role_compliant_code": "\n\nobject x;\n\nx = a ?? b;\nx = a ?? b;\nx = a ?? new object();\nx = condition ? a : b;\nvar y = new object();\n\n", "role_level": "MINOR", "role_title_en": "The simplest possible condition syntax should be used"},{"role_title": "跟踪低于阈值注释线密度的实例.", "role_desc_en": "An issue is created on a file as soon as the density of comment lines on this file is less than the required threshold. The number of comment lines to be written in order to reach the required threshold is provided by each issue message.", "role_have_noncompliant_code": "", "role_noncompliant_code": "", "role_origin_id": "rule_RSPEC-1484", "role_id": "S1484", "role_desc": "只要该文件上的注释行的密度小于所需的阈值，就会在文件上创建一个问题.为了达到所需阈值而要写入的注释行的数量由每个发布消息提供.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Track instances of below-threshold comment line density"},{"role_title": "跟踪源内问题抑制的使用.", "role_desc_en": "This rule allows you to track the usage of the SuppressMessage attributes and #pragma warning disable mechanism.", "role_have_noncompliant_code": "Y", "role_noncompliant_code": "\n\n[SuppressMessage(\"\", \"S100\")]\n...\n\n#pragma warning disable S100\n...\n#pragma warning restore S100\n\n", "role_origin_id": "rule_RSPEC-1309", "role_id": "S1309", "role_desc": "该规则允许您跟踪SuppressMessage属性和#pragma警告禁用机制的用法.", "role_type": "CodeSmell", "role_have_compliant_code": "", "role_compliant_code": "", "role_level": "MINOR", "role_title_en": "Track uses of in-source issue suppressions"},